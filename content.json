[{"title":"caliper","date":"2020-09-25T13:51:58.000Z","path":"2020/09/25/caliper/","text":"Caliper安装与使用环境安装123yum install nodejsnpm install nn 8.9.0 一. 安装绑定Caliper全局安装Cliper Cli 1npm install -g --only&#x3D;prod @hyperledger&#x2F;caliper-cli@0.3.2 绑定SDK 1caliper bind --caliper-bind-sut fabric:1.4.8 --caliper-bind-args&#x3D;-g 二. 创建文件夹Caliper需要两个配置文件 网络配置文件： 描述网络并提供连接要求 基准文件： 包含回调和用户测试文件引用 首先创建caliper-workspace父文件夹，然后在该文件夹下创建networks 和 benchmarks两个子文件夹。 三. 网络配置文件网络配置文件是通用连接配置文件的扩展，并为与网络交互的客户端提供了连接要求。该文件可以是YAML或JSON格式，本教程显示JSON格式。 创建文件在network文件夹下创建network_config.json文件，该文件包含8个部分如下面初始文件所示，后续教程将会逐步补充完整。 123456789101112131415161718&#123; &quot;caliper&quot; : &#123; &#125;, &quot;clients&quot; : &#123; &#125;, &quot;channels&quot; : &#123; &#125;, &quot;name&quot;: &#123; &#125;, &quot;organization&quot; : &#123; &#125;, &quot;peers&quot; : &#123; &#125;, &quot;certificateAuthorities&quot; : &#123; &#125;, &quot;version&quot; : &#123; &#125;&#125; 查找并复制模板first-sample-&gt;first-network-&gt;connection-org1.json将该文件所有内容复制到network_config.json文件中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&#123; &quot;name&quot;: &quot;first-network-org1&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;client&quot;: &#123; &quot;organization&quot;: &quot;Org1&quot;, &quot;connection&quot;: &#123; &quot;timeout&quot;: &#123; &quot;peer&quot;: &#123; &quot;endorser&quot;: &quot;300&quot; &#125; &#125; &#125; &#125;, &quot;organizations&quot;: &#123; &quot;Org1&quot;: &#123; &quot;mspid&quot;: &quot;Org1MSP&quot;, &quot;peers&quot;: [ &quot;peer0.org1.example.com&quot;, &quot;peer1.org1.example.com&quot; ], &quot;certificateAuthorities&quot;: [ &quot;ca.org1.example.com&quot; ] &#125; &#125;, &quot;peers&quot;: &#123; &quot;peer0.org1.example.com&quot;: &#123; &quot;url&quot;: &quot;grpcs:&#x2F;&#x2F;localhost:7051&quot;, &quot;tlsCACerts&quot;: &#123; &quot;pem&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIICVzCCAf2gAwIBAgIQJ4YZaoAxgNFIlMKJnCK8YzAKBggqhkjOPQQDAjB2MQsw\\nCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZy\\nYW5jaXNjbzEZMBcGA1UEChMQb3JnMS5leGFtcGxlLmNvbTEfMB0GA1UEAxMWdGxz\\nY2Eub3JnMS5leGFtcGxlLmNvbTAeFw0yMDA5MjQxMzE0MDBaFw0zMDA5MjIxMzE0\\nMDBaMHYxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQH\\nEw1TYW4gRnJhbmNpc2NvMRkwFwYDVQQKExBvcmcxLmV4YW1wbGUuY29tMR8wHQYD\\nVQQDExZ0bHNjYS5vcmcxLmV4YW1wbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0D\\nAQcDQgAEMJdNsNECYe4vnAX1HLFVOlcigcDvW00+pmjxdfpfZZ530ESzzYCOlruO\\n9iV&#x2F;BYcrWMC8ZFv1HYPWH4Z7bkiJ16NtMGswDgYDVR0PAQH&#x2F;BAQDAgGmMB0GA1Ud\\nJQQWMBQGCCsGAQUFBwMCBggrBgEFBQcDATAPBgNVHRMBAf8EBTADAQH&#x2F;MCkGA1Ud\\nDgQiBCAbL0P+tBNB1AA0&#x2F;7T7SDBFjlrg3n+7Boc+y0kk5&#x2F;EJRTAKBggqhkjOPQQD\\nAgNIADBFAiEAz+K66R5mn31xPcjcWSDmnhA8DmC&#x2F;&#x2F;K7j9hy3tpnNar4CIFqvxAqx\\nvEzHuvlsU99KGUhPgpfWjgPDS4NppK&#x2F;zxZse\\n-----END CERTIFICATE-----\\n&quot; &#125;, &quot;grpcOptions&quot;: &#123; &quot;ssl-target-name-override&quot;: &quot;peer0.org1.example.com&quot;, &quot;hostnameOverride&quot;: &quot;peer0.org1.example.com&quot; &#125; &#125;, &quot;peer1.org1.example.com&quot;: &#123; &quot;url&quot;: &quot;grpcs:&#x2F;&#x2F;localhost:8051&quot;, &quot;tlsCACerts&quot;: &#123; &quot;pem&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIICVzCCAf2gAwIBAgIQJ4YZaoAxgNFIlMKJnCK8YzAKBggqhkjOPQQDAjB2MQsw\\nCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZy\\nYW5jaXNjbzEZMBcGA1UEChMQb3JnMS5leGFtcGxlLmNvbTEfMB0GA1UEAxMWdGxz\\nY2Eub3JnMS5leGFtcGxlLmNvbTAeFw0yMDA5MjQxMzE0MDBaFw0zMDA5MjIxMzE0\\nMDBaMHYxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQH\\nEw1TYW4gRnJhbmNpc2NvMRkwFwYDVQQKExBvcmcxLmV4YW1wbGUuY29tMR8wHQYD\\nVQQDExZ0bHNjYS5vcmcxLmV4YW1wbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0D\\nAQcDQgAEMJdNsNECYe4vnAX1HLFVOlcigcDvW00+pmjxdfpfZZ530ESzzYCOlruO\\n9iV&#x2F;BYcrWMC8ZFv1HYPWH4Z7bkiJ16NtMGswDgYDVR0PAQH&#x2F;BAQDAgGmMB0GA1Ud\\nJQQWMBQGCCsGAQUFBwMCBggrBgEFBQcDATAPBgNVHRMBAf8EBTADAQH&#x2F;MCkGA1Ud\\nDgQiBCAbL0P+tBNB1AA0&#x2F;7T7SDBFjlrg3n+7Boc+y0kk5&#x2F;EJRTAKBggqhkjOPQQD\\nAgNIADBFAiEAz+K66R5mn31xPcjcWSDmnhA8DmC&#x2F;&#x2F;K7j9hy3tpnNar4CIFqvxAqx\\nvEzHuvlsU99KGUhPgpfWjgPDS4NppK&#x2F;zxZse\\n-----END CERTIFICATE-----\\n&quot; &#125;, &quot;grpcOptions&quot;: &#123; &quot;ssl-target-name-override&quot;: &quot;peer1.org1.example.com&quot;, &quot;hostnameOverride&quot;: &quot;peer1.org1.example.com&quot; &#125; &#125; &#125;, &quot;certificateAuthorities&quot;: &#123; &quot;ca.org1.example.com&quot;: &#123; &quot;url&quot;: &quot;https:&#x2F;&#x2F;localhost:7054&quot;, &quot;caName&quot;: &quot;ca-org1&quot;, &quot;tlsCACerts&quot;: &#123; &quot;pem&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIICUDCCAfegAwIBAgIQdgnCSGhuhWkNbc6249Ml3zAKBggqhkjOPQQDAjBzMQsw\\nCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZy\\nYW5jaXNjbzEZMBcGA1UEChMQb3JnMS5leGFtcGxlLmNvbTEcMBoGA1UEAxMTY2Eu\\nb3JnMS5leGFtcGxlLmNvbTAeFw0yMDA5MjQxMzE0MDBaFw0zMDA5MjIxMzE0MDBa\\nMHMxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1T\\nYW4gRnJhbmNpc2NvMRkwFwYDVQQKExBvcmcxLmV4YW1wbGUuY29tMRwwGgYDVQQD\\nExNjYS5vcmcxLmV4YW1wbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE\\na0TCdMmVSOzjTWNimrNe9o22cy5obbyJortbkdZPp663SEX7ZIbb7xD1PrSVOIlV\\nlHrxc&#x2F;NJ+rNzCDE37mWT8KNtMGswDgYDVR0PAQH&#x2F;BAQDAgGmMB0GA1UdJQQWMBQG\\nCCsGAQUFBwMCBggrBgEFBQcDATAPBgNVHRMBAf8EBTADAQH&#x2F;MCkGA1UdDgQiBCD6\\n2&#x2F;MOGvcQQO6GCyg7fe4x1I3Oqx3TsobGO4PfqjWHwzAKBggqhkjOPQQDAgNHADBE\\nAiAysfOd2AL5pkuJutsG02DHNxCjotuBvj1JyH7shfbMUAIgF++Ya9o5uu1QuzD+\\n4llvZ+y1mznyLgXjD4H+bwcRaiw&#x3D;\\n-----END CERTIFICATE-----\\n&quot; &#125;, &quot;httpOptions&quot;: &#123; &quot;verify&quot;: false &#125; &#125; &#125;&#125; Caliper对象表示被测试的分布式账本。在文件中添加Caliper对象，该对象包含一个blockchain属性，值为fabric 123&quot;caliper&quot;: &#123; &quot;blockchain&quot;: &quot;fabric&quot; &#125;, Client对象 将Clients对象添加到文件中，并添加以网络中的一个标识命名的属性。在该示例中，使用的身份为&#x41;&#x64;&#109;&#105;&#110;&#x40;&#x6f;&#114;&#103;&#x31;&#x2e;&#x65;&#120;&#97;&#109;&#112;&#108;&#101;&#46;&#99;&#x6f;&#109;。然后将现有Client对象嵌套在标识中。 12345678910111213&quot;clients&quot;: &#123; &quot;Admin@org1.example.com&quot;: &#123; &quot;client&quot;: &#123; &quot;connection&quot;: &#123; &quot;timeout&quot;: &#123; &quot;peer&quot;: &#123; &quot;endorser&quot;: &quot;300&quot; &#125; &#125; &#125; &#125; &#125;&#125;, 在client对象中添加credentialStore属性，在该属性下添加path属性，对应值为指向工作空间中的临时文件的路径tmp/hfc-kvs/org1。同时，仍然是在credentialStore属性下，添加cryptoStore 属性，在添加的属性下再添加一个path属性执行上述相同的文件，即tmp/hfc-kvs/org1。添加到client的内容如下： 123456&quot;credentialStore&quot;: &#123; &quot;path&quot;: &quot;tmp&#x2F;hfc-kvs&#x2F;org1&quot;, &quot;cryptoStore&quot;: &#123; &quot;path&quot;: &quot;tmp&#x2F;hfc-kvs&#x2F;org1&quot; &#125;&#125;, 在client对象下添加属性clientPrivateKey ，该属性下包含path属性，对应值指向身份标识私钥fabric-samples-&gt;first-network-&gt;crypto-config-&gt;peerOrganizations-&gt;org1.example.com-&gt;users-&gt;&#65;&#100;&#109;&#x69;&#x6e;&#64;&#111;&#x72;&#x67;&#x31;&#46;&#x65;&#120;&#x61;&#x6d;&#112;&#x6c;&#x65;&#x2e;&#x63;&#111;m-&gt;msp-&gt;keystore-&gt;priv_sk 123&quot;clientPrivateKey&quot;: &#123; &quot;path&quot;: &quot;..&#x2F;fabric-samples&#x2F;first-network&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp&#x2F;keystore&#x2F;c1967b006168083cade9ddf79932d924a3fa59698b6a5b0e1dc6c087bc79f9a3_sk&quot; &#125;, 仍然是在client对象下添加属性clientSignedCert，该属性下包含path属性，对应值指向身份签名证书。fabric-samples-&gt;first-network-&gt;crypto-config-&gt;peerOrganizations-&gt;org1.example.com-&gt;users-&gt;&#65;&#100;&#x6d;&#x69;&#110;&#64;&#x6f;&#x72;&#x67;&#x31;&#x2e;&#x65;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#x2e;&#99;&#x6f;m-&gt;msp-&gt; signedcerts -&gt; &#x61;&#x64;&#x6d;&#105;&#110;&#x40;&#x6f;&#x72;&#103;&#x31;&#46;&#x65;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#x6d;&#45;&#x63;&#x65;&#114;&#x74;&#x2e;&#x70;&#101;&#109; 123&quot;clientSignedCert&quot;:&#123; &quot;path&quot;: &quot;..&#x2F;fabric-samples&#x2F;first-network&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp&#x2F;signcerts&#x2F;Admin@org1.example.com-cert.pem&quot; &#125;, client对象所需要添加的所有属性，最终如下所示： 1234567891011121314151617181920212223242526&quot;clients&quot;: &#123; &quot;Admin@org1.example.com&quot;: &#123; &quot;client&quot;: &#123; &quot;credentialStore&quot;: &#123; &quot;path&quot;: &quot;tmp&#x2F;hfc-kvs&#x2F;org1&quot;, &quot;cryptoStore&quot;: &#123; &quot;path&quot;: &quot;tmp&#x2F;hfc-kvs&#x2F;org1&quot; &#125; &#125;, &quot;organization&quot;: &quot;Org1&quot;, &quot;clientPrivateKey&quot;: &#123; &quot;path&quot;: &quot;..&#x2F;fabric-samples&#x2F;first-network&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp&#x2F;keystore&#x2F;c1967b006168083cade9ddf79932d924a3fa59698b6a5b0e1dc6c087bc79f9a3_sk&quot; &#125;, &quot;clientSignedCert&quot;:&#123; &quot;path&quot;: &quot;..&#x2F;fabric-samples&#x2F;first-network&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp&#x2F;signcerts&#x2F;Admin@org1.example.com-cert.pem&quot; &#125;, &quot;connection&quot;: &#123; &quot;timeout&quot;: &#123; &quot;peer&quot;: &#123; &quot;endorser&quot;: &quot;300&quot; &#125; &#125; &#125; &#125; &#125; &#125;, channel对象 在文件中添加一个channels对象，并在channel之后添加一个名称属性。默认频道名称（本教程中使用的名称）为mychannel。根据频道名称，添加两个属性，分别为created和chaincodes。设置created为布尔变量true 1&quot;created&quot;:true, chaincodes作为一个数组，带有两个属性，分别为id和version，id代表的是链码id，在本次例子中为mycc，version指明链码版本，在本次例子中为1.0 123456&quot;chaincodes&quot;: [ &#123; &quot;id&quot;:&quot;mycc&quot;, &quot;version&quot;:&quot;1.0&quot; &#125; ] 最终channels对象如下所示： 1234567891011&quot;channels&quot;: &#123; &quot;mychannel&quot;: &#123; &quot;created&quot; : true, &quot;chaincodes&quot;: [ &#123; &quot;id&quot;:&quot;mycc&quot;, &quot;version&quot;:&quot;1.0&quot; &#125; ] &#125; &#125;, Organizations 对象 在Organizations 对象中的Org1中添加两个属性： adminPrivateKey ：管理员用户私钥路径 signedCert ：管理员用户签名证书 在本次示例中使用的身份是管理员用户，所以对应路径与上述client对象相同。如果使用不同的身份，对应管理员用户密钥和证书可以在以下路径中查找：fabric-samples-&gt;first-network-&gt;crypto-config-&gt;peerOrganizations-&gt;org1.example.com-&gt;users-&gt;&#65;&#x64;&#109;&#x69;&#110;&#64;&#111;&#x72;&#x67;&#49;&#x2e;&#101;&#120;&#x61;&#x6d;&#112;&#108;&#101;&#46;&#99;&#111;m-&gt;msp 下面内容应该添加到org1中： 123456&quot;adminPrivateKey&quot;: &#123; &quot;path&quot;: &quot;..&#x2F;fabric-samples&#x2F;first-network&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp&#x2F;keystore&#x2F;c1967b006168083cade9ddf79932d924a3fa59698b6a5b0e1dc6c087bc79f9a3_sk&quot; &#125;, &quot;signedCert&quot;: &#123; &quot;path&quot;: &quot;..&#x2F;fabric-samples&#x2F;first-network&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp&#x2F;signcerts&#x2F;Admin@org1.example.com-cert.pem&quot; &#125; Organizations对象最后应该包括以下内容： 123456789101112131415161718&quot;organizations&quot;:&#123; &quot;Org1&quot;: &#123; &quot;mspid&quot;: &quot;Org1MSP&quot;, &quot;peers&quot;: [ &quot;peer0.org1.example.com&quot;, &quot;peer1.org1.example.com&quot; ], &quot;certificateAuthorities&quot;: [ &quot;ca.org1.example.com&quot; ], &quot;adminPrivateKey&quot;: &#123; &quot;path&quot;: &quot;..&#x2F;fabric-samples&#x2F;first-network&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp&#x2F;keystore&#x2F;c1967b006168083cade9ddf79932d924a3fa59698b6a5b0e1dc6c087bc79f9a3_sk&quot; &#125;, &quot;signedCert&quot;: &#123; &quot;path&quot;: &quot;..&#x2F;fabric-samples&#x2F;first-network&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp&#x2F;signcerts&#x2F;Admin@org1.example.com-cert.pem&quot; &#125; &#125; &#125;, 网络配置文件最终网络配置文件在补充完整之后，需要仔细确认确保对应密钥和证书的路径是否正确，整个完整文件如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&#123; &quot;caliper&quot;: &#123; &quot;blockchain&quot;: &quot;fabric&quot; &#125;, &quot;clients&quot;: &#123; &quot;Admin@org1.example.com&quot;: &#123; &quot;client&quot;: &#123; &quot;credentialStore&quot;: &#123; &quot;path&quot;: &quot;tmp&#x2F;hfc-kvs&#x2F;org1&quot;, &quot;cryptoStore&quot;: &#123; &quot;path&quot;: &quot;tmp&#x2F;hfc-kvs&#x2F;org1&quot; &#125; &#125;, &quot;organization&quot;: &quot;Org1&quot;, &quot;clientPrivateKey&quot;: &#123; &quot;path&quot;: &quot;..&#x2F;fabric-samples&#x2F;first-network&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp&#x2F;keystore&#x2F;c1967b006168083cade9ddf79932d924a3fa59698b6a5b0e1dc6c087bc79f9a3_sk&quot; &#125;, &quot;clientSignedCert&quot;:&#123; &quot;path&quot;: &quot;..&#x2F;fabric-samples&#x2F;first-network&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp&#x2F;signcerts&#x2F;Admin@org1.example.com-cert.pem&quot; &#125;, &quot;connection&quot;: &#123; &quot;timeout&quot;: &#123; &quot;peer&quot;: &#123; &quot;endorser&quot;: &quot;300&quot; &#125; &#125; &#125; &#125; &#125; &#125;, &quot;channels&quot;: &#123; &quot;mychannel&quot;: &#123; &quot;created&quot; : true, &quot;chaincodes&quot;: [ &#123; &quot;id&quot;:&quot;mycc&quot;, &quot;version&quot;:&quot;1.0&quot; &#125; ] &#125; &#125;, &quot;name&quot;: &quot;test-network-org1&quot;, &quot;organizations&quot;:&#123; &quot;Org1&quot;: &#123; &quot;mspid&quot;: &quot;Org1MSP&quot;, &quot;peers&quot;: [ &quot;peer0.org1.example.com&quot;, &quot;peer1.org1.example.com&quot; ], &quot;certificateAuthorities&quot;: [ &quot;ca.org1.example.com&quot; ], &quot;adminPrivateKey&quot;: &#123; &quot;path&quot;: &quot;..&#x2F;fabric-samples&#x2F;first-network&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp&#x2F;keystore&#x2F;c1967b006168083cade9ddf79932d924a3fa59698b6a5b0e1dc6c087bc79f9a3_sk&quot; &#125;, &quot;signedCert&quot;: &#123; &quot;path&quot;: &quot;..&#x2F;fabric-samples&#x2F;first-network&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp&#x2F;signcerts&#x2F;Admin@org1.example.com-cert.pem&quot; &#125; &#125; &#125;, &quot;peers&quot;: &#123; &quot;peer0.org1.example.com&quot;: &#123; &quot;url&quot;: &quot;grpcs:&#x2F;&#x2F;localhost:7051&quot;, &quot;tlsCACerts&quot;: &#123; &quot;pem&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIICVzCCAf2gAwIBAgIQJ4YZaoAxgNFIlMKJnCK8YzAKBggqhkjOPQQDAjB2MQsw\\nCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZy\\nYW5jaXNjbzEZMBcGA1UEChMQb3JnMS5leGFtcGxlLmNvbTEfMB0GA1UEAxMWdGxz\\nY2Eub3JnMS5leGFtcGxlLmNvbTAeFw0yMDA5MjQxMzE0MDBaFw0zMDA5MjIxMzE0\\nMDBaMHYxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQH\\nEw1TYW4gRnJhbmNpc2NvMRkwFwYDVQQKExBvcmcxLmV4YW1wbGUuY29tMR8wHQYD\\nVQQDExZ0bHNjYS5vcmcxLmV4YW1wbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0D\\nAQcDQgAEMJdNsNECYe4vnAX1HLFVOlcigcDvW00+pmjxdfpfZZ530ESzzYCOlruO\\n9iV&#x2F;BYcrWMC8ZFv1HYPWH4Z7bkiJ16NtMGswDgYDVR0PAQH&#x2F;BAQDAgGmMB0GA1Ud\\nJQQWMBQGCCsGAQUFBwMCBggrBgEFBQcDATAPBgNVHRMBAf8EBTADAQH&#x2F;MCkGA1Ud\\nDgQiBCAbL0P+tBNB1AA0&#x2F;7T7SDBFjlrg3n+7Boc+y0kk5&#x2F;EJRTAKBggqhkjOPQQD\\nAgNIADBFAiEAz+K66R5mn31xPcjcWSDmnhA8DmC&#x2F;&#x2F;K7j9hy3tpnNar4CIFqvxAqx\\nvEzHuvlsU99KGUhPgpfWjgPDS4NppK&#x2F;zxZse\\n-----END CERTIFICATE-----\\n&quot; &#125;, &quot;grpcOptions&quot;: &#123; &quot;ssl-target-name-override&quot;: &quot;peer0.org1.example.com&quot;, &quot;hostnameOverride&quot;: &quot;peer0.org1.example.com&quot; &#125; &#125;, &quot;peer1.org1.example.com&quot;: &#123; &quot;url&quot;: &quot;grpcs:&#x2F;&#x2F;localhost:8051&quot;, &quot;tlsCACerts&quot;: &#123; &quot;pem&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIICVzCCAf2gAwIBAgIQJ4YZaoAxgNFIlMKJnCK8YzAKBggqhkjOPQQDAjB2MQsw\\nCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZy\\nYW5jaXNjbzEZMBcGA1UEChMQb3JnMS5leGFtcGxlLmNvbTEfMB0GA1UEAxMWdGxz\\nY2Eub3JnMS5leGFtcGxlLmNvbTAeFw0yMDA5MjQxMzE0MDBaFw0zMDA5MjIxMzE0\\nMDBaMHYxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQH\\nEw1TYW4gRnJhbmNpc2NvMRkwFwYDVQQKExBvcmcxLmV4YW1wbGUuY29tMR8wHQYD\\nVQQDExZ0bHNjYS5vcmcxLmV4YW1wbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0D\\nAQcDQgAEMJdNsNECYe4vnAX1HLFVOlcigcDvW00+pmjxdfpfZZ530ESzzYCOlruO\\n9iV&#x2F;BYcrWMC8ZFv1HYPWH4Z7bkiJ16NtMGswDgYDVR0PAQH&#x2F;BAQDAgGmMB0GA1Ud\\nJQQWMBQGCCsGAQUFBwMCBggrBgEFBQcDATAPBgNVHRMBAf8EBTADAQH&#x2F;MCkGA1Ud\\nDgQiBCAbL0P+tBNB1AA0&#x2F;7T7SDBFjlrg3n+7Boc+y0kk5&#x2F;EJRTAKBggqhkjOPQQD\\nAgNIADBFAiEAz+K66R5mn31xPcjcWSDmnhA8DmC&#x2F;&#x2F;K7j9hy3tpnNar4CIFqvxAqx\\nvEzHuvlsU99KGUhPgpfWjgPDS4NppK&#x2F;zxZse\\n-----END CERTIFICATE-----\\n&quot; &#125;, &quot;grpcOptions&quot;: &#123; &quot;ssl-target-name-override&quot;: &quot;peer1.org1.example.com&quot;, &quot;hostnameOverride&quot;: &quot;peer1.org1.example.com&quot; &#125; &#125; &#125;, &quot;certificateAuthorities&quot;: &#123; &quot;ca.org1.example.com&quot;: &#123; &quot;url&quot;: &quot;https:&#x2F;&#x2F;localhost:7054&quot;, &quot;caName&quot;: &quot;ca-org1&quot;, &quot;tlsCACerts&quot;: &#123; &quot;pem&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIICUDCCAfegAwIBAgIQdgnCSGhuhWkNbc6249Ml3zAKBggqhkjOPQQDAjBzMQsw\\nCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZy\\nYW5jaXNjbzEZMBcGA1UEChMQb3JnMS5leGFtcGxlLmNvbTEcMBoGA1UEAxMTY2Eu\\nb3JnMS5leGFtcGxlLmNvbTAeFw0yMDA5MjQxMzE0MDBaFw0zMDA5MjIxMzE0MDBa\\nMHMxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1T\\nYW4gRnJhbmNpc2NvMRkwFwYDVQQKExBvcmcxLmV4YW1wbGUuY29tMRwwGgYDVQQD\\nExNjYS5vcmcxLmV4YW1wbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE\\na0TCdMmVSOzjTWNimrNe9o22cy5obbyJortbkdZPp663SEX7ZIbb7xD1PrSVOIlV\\nlHrxc&#x2F;NJ+rNzCDE37mWT8KNtMGswDgYDVR0PAQH&#x2F;BAQDAgGmMB0GA1UdJQQWMBQG\\nCCsGAQUFBwMCBggrBgEFBQcDATAPBgNVHRMBAf8EBTADAQH&#x2F;MCkGA1UdDgQiBCD6\\n2&#x2F;MOGvcQQO6GCyg7fe4x1I3Oqx3TsobGO4PfqjWHwzAKBggqhkjOPQQDAgNHADBE\\nAiAysfOd2AL5pkuJutsG02DHNxCjotuBvj1JyH7shfbMUAIgF++Ya9o5uu1QuzD+\\n4llvZ+y1mznyLgXjD4H+bwcRaiw&#x3D;\\n-----END CERTIFICATE-----\\n&quot; &#125;, &quot;httpOptions&quot;: &#123; &quot;verify&quot;: false &#125; &#125; &#125;&#125; 四. 测试回调文件测试回调文件与部署的智能合约在基准测试期间交互，每个测试回调函数必须包含3个函数： init - 用于初始化账本以运行会话 run - 在基准测试监控阶段用于与智能合约进行交互 end - 在run阶段完成之后结束并清理。 创建文件在benchmarks文件夹中创建callbacks子文件夹，在该文件夹中创建文件query.js，后面将对该文件进行补充。 由于本次部署链码为 chaincode_example02 ,可在fabric-samples-&gt;chaincode-&gt;chaincode_example02中查找 文件设置Caliper使用以下两个方法与部署的智能合约进行交互： invokeSmartContract (ctx, contractId, contractVersion, args)querySmartContract (ctx, contractId, contractVersion, args) 其中： ctx 指用户上下文 contractId 为智能合约名称，本示例中为mycc contractVersion 为智能合约版本，本示例中为1.0 args 为一个对象，主要包括 chaincodeFunction 调用的智能合约函数名称 invokerIdentity 调用函数时的用户身份，本示例中为 &#x41;&#100;&#x6d;&#105;&#x6e;&#x40;&#111;&#114;&#x67;&#49;&#x2e;&#x65;&#120;&#97;&#x6d;&#112;&#x6c;&#x65;&#46;&#99;&#x6f;&#109; chaincodeArguments 函数调用时传递给函数的参数列表 下面是文件基本模板： 123456789101112131415161718&#39;use strict&#39;;module.exports.info &#x3D; &#39;Template callback&#39;;const contractID &#x3D; &#39;mycc&#39;;const version &#x3D; &#39;1.0&#39;;let bc, ctx, clientArgs, clientIdx;module.exports.init &#x3D; async function(blockchain, context, args) &#123;&#125;;module.exports.run &#x3D; function() &#123; return Promise.resolve();&#125;;module.exports.end &#x3D; async function() &#123;&#125;; Init 函数初始化传递run函数中需要使用到的内容，参数。 本示例中，通过等待invokeSmartContract调用完成。通过区块链对象将上下文，合约名称，合约版本以及包含以下内容的对象：chaincodeFunction设置为query; invokeIdentity设为&#x61;&#x64;&#109;&#105;&#110;&#x40;&#111;&#114;&#103;&#46;&#x65;&#120;&#x61;&#x6d;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;; chaincodeArguments设置为包含的数组a，需要将参数传递给query。 该函数应如下所示： 12345678910111213141516module.exports.init &#x3D; async function(blockchain, context, args) &#123; bc &#x3D; blockchain; ctx &#x3D; context; clientArgs &#x3D; args; clientIdx &#x3D; context.clientIdx.toString(); try &#123; const myArgs &#x3D; &#123; chaincodeFunction: &#39;query&#39;, invokerIdentity: &#39;Admin@org1.example.com&#39;, chaincodeArguments: [&#39;a&#39;] &#125;; return bc.bcObj.querySmartContract(ctx, contractID, version, myArgs); &#125; catch (error) &#123; console.log(&#96;Smart Contract threw with error: $&#123;error&#125;&#96; ); &#125;&#125;; Run 函数本次只测试query函数，所以函数内容与Init函数相同 12345678module.exports.run &#x3D; async function() &#123; const myArgs &#x3D; &#123; chaincodeFunction: &#39;query&#39;, invokerIdentity: &#39;Admin@org1.example.com&#39;&#39;, chaincodeArguments: [&#39;a&#39;] &#125;; return bc.bcObj.invokeSmartContract(ctx, contractID, version, myArgs);&#125;; End 函数此功能用于在测试后清除，因为它会删除该init功能中创建的数据。如果测试的智能合约没有删除功能，则不使用此功能，此功能将保持为空。 12module.exports.end &#x3D; async function() &#123;&#125;; 最终文件12345678910111213141516171819202122232425262728293031323334353637&#39;use strict&#39;;module.exports.info &#x3D; &#39;Template callback&#39;;const contractID &#x3D; &#39;mycc&#39;;const version &#x3D; &#39;1.0&#39;;let bc, ctx, clientArgs, clientIdx;module.exports.init &#x3D; async function(blockchain, context, args) &#123; bc &#x3D; blockchain; ctx &#x3D; context; clientArgs &#x3D; args; clientIdx &#x3D; context.clientIdx.toString(); try &#123; const myArgs &#x3D; &#123; chaincodeFunction: &#39;query&#39;, invokerIdentity: &#39;Admin@org1.example.com&#39;, chaincodeArguments: [&#39;a&#39;] &#125;; return bc.bcObj.querySmartContract(ctx, contractID, version, myArgs); &#125; catch (error) &#123; console.log(&#96;Smart Contract threw with error: $&#123;error&#125;&#96; ); &#125;&#125;;module.exports.run &#x3D; async function() &#123; const myArgs &#x3D; &#123; chaincodeFunction: &#39;query&#39;, invokerIdentity: &#39;Admin@org1.example.com&#39;, chaincodeArguments: [&#39;a&#39;] &#125;; return bc.bcObj.invokeSmartContract(ctx, contractID, version, myArgs);&#125;;module.exports.end &#x3D; async function() &#123;&#125;; 五. 基准配置文件基准测试配置文件定义基准测试轮数并引用已定义的回调。它将指定生成负载时要使用的测试客户端的数量，测试的轮数，每一轮的持续时间，每一轮中的负载生成方法以及每一轮中要使用的回调。 该文件是YAML文件。YAML文件区分大小写，所有标签均小写。 该文件将具有三个需要填充的根块。如下所示： 12345test:monitor:observer: 创建文件在benchmarks文件夹下创建一个myAssetBenchmark.yaml文件，后续进行补充。 test首先添加一个名为test的根块。在此块中添加： name：对应值为my-asset-benchmark description ：带有简短描述作为值的键，在此示例中为test benchmark workers具有以下键和值： type: local number: 2 到目前为止看起来应该像这样： 还添加一个名为rounds的块。该块包含每个测试回合，每个回合均以唯一的回合标签为首。回合可用于基准化不同的智能合约方法或以不同的方式对同一方法进行基准测试。 该round块包含以下内容： label -用于回合的唯一标头标签。 description -对正在运行的回合的描述。 chaincodeId -正在测试的链码ID。 txDuration -通过持续时间长度。 rateControl -带有选项和类型的速率控制方法。 callback -被测试的回调文件的路径，在这种情况下，这是queryAssetBenchmark.js文件。 arguments -调用时将传递给回调文件的可选参数数组。 示例如下所示： 12345678910rounds: - label: open description: Query benchmark chaincodeId: mycc txDuration: 30 rateControl: type: fixed-backlog opts: unfinished_per_client: 2 callback: benchmarks&#x2F;callbacks&#x2F;query.js monitor添加名为monitor的根块，其中单个键type的值为none， 因为在本次测试中不进行任何资源监控 示例如下： 123monitor: type: - none observer添加名为observer的根块，其中包含两个键type 和 interval，对应的值设置为local和5，代表着使用本地统计信息每五秒钟观察一次测试进度。 示例如下： 123observer: type: local interval: 5 最终文件123456789101112131415161718192021222324test: name: simple description: This is an example benchmark for caliper, to test the backend DLT&#39;s performance with simple account opening &amp; querying transactions workers: type: local number: 2 rounds: - label: open description: Query benchmark chaincodeId: mycc txDuration: 30 rateControl: type: fixed-backlog opts: unfinished_per_client: 2 callback: benchmarks&#x2F;callbacks&#x2F;query.js monitor: type: - none observer: type: local interval: 5 六. 运行并获取结果使用上述步骤准备的材料使用Caliper Cli运行性能测试，设置网络配置文件，测试配置文件以及工作空间的路径。如下所示 caliper-networkconfig： networks/network_config.json caliper-benchconfig： benchmarks/myAssetBenchmark.yaml caliper-workspace： ./ 因为已经安装且实例化链码，因此Caliper唯一需要的操作就是在测试阶段使用启用了发现功能的fabric gateway，因此需要在命令中指明以下标志： caliper-flow-only-test caliper-fabric-gateway-usegateway caliper-fabric-gateway-discovery 运行命令确认处于caliper-workspace目录 在终端运行以下命令： 1caliper launch master --caliper-benchconfig benchmarks&#x2F;myAssetBenchmark.yaml --caliper-networkconfig networks&#x2F;network_config.json --caliper-workspace .&#x2F; --caliper-flow-only-test --caliper-fabric-gateway-usegateway --caliper-fabric-gateway-discovery 问题： 开始命令运行后出现gRPC未安装错误：进入 /usr/local/lib/node_modules/fabric-network执行以下命令： 1npm rebuild 回到caliper-workspace目录，再次执行命令,结果如下： 1234567891011121314151617181920212223242526+------+------+------+-----------------+-----------------+-----------------+-----------------+------------------+| Name | Succ | Fail | Send Rate (TPS) | Max Latency (s) | Min Latency (s) | Avg Latency (s) | Throughput (TPS) ||------|------|------|-----------------|-----------------|-----------------|-----------------|------------------|| open | 42 | 0 | 1.5 | 2.62 | 0.59 | 2.28 | 1.4 |+------+------+------+-----------------+-----------------+-----------------+-----------------+------------------+2020.09.26-14:10:07.479 info [caliper] [round-orchestrator] Finished round 1 (open) in 30.324 seconds2020.09.26-14:10:07.479 info [caliper] [report-builder] ### All test results ###2020.09.26-14:10:07.481 info [caliper] [report-builder] +------+------+------+-----------------+-----------------+-----------------+-----------------+------------------+| Name | Succ | Fail | Send Rate (TPS) | Max Latency (s) | Min Latency (s) | Avg Latency (s) | Throughput (TPS) ||------|------|------|-----------------|-----------------|-----------------|-----------------|------------------|| open | 42 | 0 | 1.5 | 2.62 | 0.59 | 2.28 | 1.4 |+------+------+------+-----------------+-----------------+-----------------+-----------------+------------------+2020.09.26-14:10:07.498 info [caliper] [report-builder] Generated report with path &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper-workspace&#x2F;report.html2020.09.26-14:10:07.498 info [caliper] [monitor.js] Stopping all monitors2020.09.26-14:10:07.499 info [caliper] [worker-orchestrator] Sending exit message to connected workers2020.09.26-14:10:07.500 info [caliper] [message-handler] Handling &quot;exit&quot; message2020.09.26-14:10:07.500 info [caliper] [message-handler] Handling &quot;exit&quot; message2020.09.26-14:10:07.500 info [caliper] [message-handler] Handled &quot;exit&quot; message for worker 1, exiting process2020.09.26-14:10:07.500 info [caliper] [message-handler] Handled &quot;exit&quot; message for worker 0, exiting process2020.09.26-14:10:07.501 info [caliper] [round-orchestrator] Benchmark finished in 49.014 seconds. Total rounds: 1. Successful rounds: 1. Failed rounds: 0.2020.09.26-14:10:07.501 info [caliper] [caliper-engine] Skipping end command due to benchmark flow conditioning2020.09.26-14:10:07.501 info [caliper] [cli-launch-master] Benchmark successfully finished 在当前目录中可以看到生成一个新的report.html文件。 1234567[root@localhost caliper-workspace]# lltotal 112drwxr-xr-x. 3 root root 50 Sep 26 14:08 benchmarks-rw-r--r--. 1 root root 103725 Sep 26 14:10 caliper.logdrwxr-xr-x. 2 root root 32 Sep 26 14:07 networks-rw-r--r--. 1 root root 7290 Sep 26 14:10 report.htmldrwxr-xr-x. 3 root root 20 Sep 26 14:00 tmp"},{"title":"博客迁移","date":"2020-09-21T08:39:10.000Z","path":"2020/09/21/helloblog/","text":"本博客已经迁移到新的个人博客 Harlan"},{"title":"简述椭圆曲线算法（ECC）","date":"2020-04-01T06:37:05.000Z","path":"2020/04/01/ECC/","text":"本文主要目的是对椭圆曲线做一个形象的介绍，比较通俗的可以理解与传统的基于取模运算的加密算法如RSA的区别。没有涉及过多密码学运算和数论知识。如果感兴趣可以参考Elliptic Curve Cryptography: a gentle introduction，比较容易看懂，其中还配置了一个可视化的椭圆曲线工具，本文的配图都是利用该工具生成的。 可视化工具github项目链接 好了，开始进入主题：Elliptic Curve Cryptography (ECC)1. 简单概念Elliptic Curve Cryptography 椭圆加密算法，简称ECC，是基于椭圆曲线数学理论的一种非对称加密算法（公钥加密算法）,与RSA这些广为使用的加密算法相比，尽管目前ECC加密算法也应用的很广泛，当其基本的实现原理还是对大多数人来说比较陌生。 特性：与RSA相比可以使用更短的密钥实现与RSA相当或者更高的安全性。 一下方程式表示了椭圆曲线，其中a, b, c, d为系数。 1y^2 &#x3D; ax^3 + bx^2 + cx + d 当a = 1, b = 0, c = -7, d = 10 时，方程表示如下图所示： 1y^2 &#x3D; x^3 - 7x + 10 此时曲线显示如下图蓝线所示： 可以看出椭圆曲线并不是椭圆形的，形状与名称并没有太大联系。 2. 运算法则2.1 加法在这里我们取最简单的一种方式来解释椭圆曲线中的加法，其它的特殊方式可以参考 Elliptic Curve Cryptography: a gentle introduction 如下图所示，过曲线上两点P和Q画一条直线，与曲线交点关于x轴对称位置的点R，即为P + Q。 R = P + Q 2.2 二倍运算当2.1中Q = P的时候，可以得到R = 2P。但此时无法用上述方法进行解释。因此在这种情况下，两点重叠的时候，将椭圆曲线在P点的切线，与椭圆曲线的交点关于x轴对称位置的点，定义为R，即2P。如下图所示： 2.3 无穷远点当Q = -P 的时候，此时两点所在直线与x轴垂直，此时不会与曲线有交点，此时定义P + Q = 0 ，其中0称之为无穷远点。 此种情况如下图所示： 综上，当给出椭圆曲线上一点G的时候，根据加法和二倍运算，可以求出2G、3G（拆分为G+2G）、… 、nG。 2.4 乘法除了定义完加法和二倍运算，接下来定义乘法： 1nG &#x3D; G + G + ... + G 看成n个G相加。 如果按照上面方法应该进行n次加法，这样计算量较大。 另一种较为快速的方法就是先做倍数再做加法，如下面例子所示 1151P &#x3D; 2^7P + 2^4P +2^2P + 2^1P + 2^0P 可以先拿到P 在根据二倍运算获取2P 2P与P相加 2P取二倍运算得到4P 以此类推 这样只是做了简单的倍数运算和加法运算 但是当给出的是nG 和G 的时候如何求出n，是一个困难的问题，这也就是椭圆曲线加密背后的数学难题，详细过程可以参考Elliptic Curve Cryptography: finite fields and discrete logarithms。从一个方向上进行计算十分简单，当逆过来的时候却十分困难，这于大数分解和离散对数问题是一致的。 3. 有限域上的椭圆曲线在我们上面描述的椭圆曲线中，可以从给出的示例图看出，对应的椭圆曲线都是光滑的曲线，这是基于实数域上的椭圆曲线。但是在实际上的椭圆曲线加密算法当中，用的不是实数域上的椭圆曲线，而是有限域上的椭圆曲线。 所谓有限域指的就是具有有限数量元素的集合，其中一个有限域的例子就是一个集合的整数模p，此时的p指的是一个素数，该有限与用GF(p)代表。 原本实数域上的椭圆曲线定义如下： 12&#123; (x, y) \\in(\\mathbb&#123;R_p&#125;)^2 | y^2 &#x3D; x^3 + ax +b, 4a^3 +27b^2 \\neq 0 &#125; \\bigcup &#123;0&#125;(\\mathbb&#123;F_p&#125;)^2 有限域上的椭圆曲线定义如下： 123&#123; (x, y) \\in(\\mathbb&#123;F_p&#125;)^2 | y^2 \\equiv x^3 + ax +b(mod p), 4a^3 +27b^2 !\\equiv 0 (mod p)&#125; \\bigcup &#123;0&#125; 其中0代表无穷远点，a和b是此时的椭圆曲线不再是一条光滑的曲线而是一个有限点集。 当a = 1, b = 1, p = 23的时候，此时有限域上的椭圆曲线如下图所示： 可以看到椭圆曲线不再是“曲线”，而是一堆点集。 此时有限域中的直线也不同于实数域中的实线。在有限域中直线定义为满足下面等式的点的集合。 1ax + by + c \\equiv 0(mod p) 4.有限域上的计算在有限域上如何计算 xG： 在有限域GF(p)中给定椭圆曲线上两点P和Q，计算R = P + Q公式及过程如下： 1234567P(x_p,y_p),Q(x_q,y_q), R(x_r,y_r)x_r &#x3D; (m^2 -x_p - x_q) mod py_r &#x3D; (m(x_p - x_r)-y_p) mod pm &#x3D; (y_q - y_p) \\cdot (x_q - x_p)^&#123;-1&#125; mod p 若 P = Q，则有： 1m &#x3D; (3x_p^2+a) \\cdot (2y_p)^&#123;-1&#125; mod p 根据以上公式仍然可以跟实数域上一般计算出对应2G、3G、…、nG 5. 椭圆曲线使用原理椭圆曲线加解密也是属于公钥加密体系的内容，也就是说需要跟RSA这种公钥加密算法一样有对应的公钥和私钥，那这里面的公钥和私钥又是如何得到的？ 椭圆曲线加密中需要找到类似于RSA和DH类似的质因子分解或者离散对数求解的数学难题。在前面已经讲到给定椭圆曲线上一点G，那么求出nG是容易的，但是当拥有G和nG的时候计算出n却是困难的，这就是椭圆曲线上的离散对数问题。 先设私钥为k，可以计算出公钥为P = kG，其中G为曲线上一点 5.1 ECC加解密原理5.1.1 加密 选择随机数 r； 对消息进行加密 ( 所谓对消息进行加密即先对消息进行编码映射到曲线上的一点M，再对M进行计算 )，生成密文C，其中密文为一个点对 1C &#x3D; &#123;rG, M + rP&#125; 其中P为公钥 5.1.2 解密原理 先计算出M 123M + rP - k(rG) &#x3D; M + r(kG) - k(rG) &#x3D; M 再对M进行解密获取原始消息。 其中k 为私钥， P为公钥 5.2 ECC签名原理(ECDSA)假设需要签名消息为M，M对应的hash值为h，一般签名都是对消息的hash值进行操作，而不是对消息本身。公钥加密速度慢，一旦消息过长，对消息本身签名会造成较大的计算和时间开销，一般采用对消息的hash进行签名。 5.2.1 私钥签名 取随机数r，计算rG 根据r ， h， 私钥k，进行以下计算，其中x为G点横坐标 1s &#x3D; (h + kx) &#x2F; r 生成签名S = {rG, s} 将M，签名S发送给接收方 5.2.2 公钥验签 接收方收到消息M，签名S = {rG, s} 根据M计算hash值h 使用发送方公钥P计算1hG &#x2F; s + xP &#x2F; s 将计算结果与rG进行比较，若相当则验证成功。 1234567hG &#x2F; s + xP &#x2F;s&#x3D; hG &#x2F; s + x(kG) &#x2F; s&#x3D; (h + xk)G &#x2F; s &#x3D; (h + xk)G r &#x2F; (h + kx) &#x3D; rG 可以注意到由于随机数的存在，所以对于同一条消息，用同一种算法，生成的签名都是不一样的。 5.3 椭圆曲线密钥交换( ECDH )当通讯双方需要安全地交换信息且即使第三方拿到交换的信息也无法解码。一般ECDH用来实现交换对称密钥。流程如下，设通信双方是Alice和Bob Alice 生成私钥和公钥：123private key : k_Apublic key : P_A &#x3D; k_AG Bob 生成私钥和公钥：123private key : k_Bpublic key : P_B &#x3D; k_BG Alice和Bob通过非安全通道交换各自的公钥 Alice在收到Bob的公钥后，进行以下计算：1S &#x3D; k_AP_B Bob在收到Alice的公钥后，进行以下计算：1S &#x3D; k_BP_A 可以看到Alice和Bob计算出来的密钥S是相同的，因为有：1S &#x3D; k_AP_B &#x3D; k_A(k_BG) &#x3D; k_B(k_AG) &#x3D; k_BP_A 此时通信双方拥有共享密钥，就可以通过对称加密来安全交换信息。 有时候会看到ECDHE，其中多出来的“E”主要指“Ephemeral”，即临时，短暂的意思，意味着交换的密钥是作为临时密钥，并非用来做长久密钥的，如TLS 5.4 比较此处比较主要引自博客 5.4.1 密码强度比较 对称密钥 ECC RSA 80 163 1024 112 233 2240 128 283 3072 192 409 7680 拿表中第一行数据来举例，表示1024-bit的RSA密钥强度、163-bit的ECC密钥强度和80-bit的对称密钥强度相当。 即要达到相同的密钥强度所需要的的密钥长度： 对称 &lt; ECC &lt; RSA 5.4.1 计算性能比较环境：Intel Xeon CPU E5520 @ 2.27GHz 基础：tommathlib 结果(单位us）： 算法 验证 签名 RSA-1024 12 511 RSA-2048 30 3270 ECDSA-192 590 490 可以看出对于ECDSA来说生成签名和验证签名开销差不多，对于RSA来说，验证签名比生成签名高效。 总的来说： ECDSA生成签名性能比RSA好； RSA验证签名性能比ECDSA好； ECDSA签名算法适合用于签名和验证签名频率相近的场景，如P2P通道建立 RSA签名算法适用于，验证频率高，签名频率低的场景。"},{"title":"SGX远程认证流程","date":"2020-03-27T15:48:50.000Z","path":"2020/03/27/SGX/","text":"阅读提示：文章由intel官方文档 翻译而来，其中客户端与服务提供商角色可能有点混乱，所以在阅读过程请参照文中最后的流程图片，这样会有比较清晰的阅读体验。 1. 使用条件 类型 型号/工具 操作系统 Win10, Linux 硬件 6th gen Intel® Core™ 或以上, Intel® Xeon® E3 v6 软件 windows：VS2015专业版或者更新版，Intel® Software Guard Extensions SDK for Windows* (Intel® SGX SDK for Windows*) 要求 C/C++编程 2. 简介如今，现实世界中的应用程序越来越需要处理敏感数据。 诸如用户的身份验证凭证，机密文件或高价值的知识产权都是必须防止被暴露和泄露给其他未授权的第三方的信息。 由于安全漏洞会给企业造成重大经济损失和声誉损害，因此当前有强烈的需求要求开发能够守卫和保护机密的应用程序。 当前硬件和软件安全性方面的最新进展为开发人员提供了多种工具和技术供您选择，以实现这一目标。 3. Intel® SGX的任务根据简介中可以知道当前在需要开发能够守卫并保护机密的应用程序来确保用户数据不会遭受系统或者物理层面的攻击。英特尔®软件防护扩展（Intel®SGX）就是一种这样的技术，随着第六代英特尔®酷睿™处理器的推出而，该技术也开始可用。英特尔SGX允许应用程序通过在应用程序空间内创建不易受到恶意行为者检查的保护区（Enclave）来控制自身的安全性-即使当攻击来自特权软件，无论是受威胁的操作系统，虚拟内存管理器还是设备驱动程序。 4. 通过远程证明提供密钥将Intel SGX与其他现代软件和硬件技术结合使用可以帮助应用程序为现有机密提供最佳保护。 但是这些机密在传输过程中仍然容易受到攻击。因此应用程序如何首先获取机密是一个问题。 在某些情况下，可能会要求用户提供该信息（指密钥等敏感信息），但是在平台上缺少可信输入/输出的情况下，该输入可能会泄露给恶意软件。一些敏感内容，例如受数字版权管理（DRM）保护的媒体，甚至可能根本不是用户生成的，可能源自远程服务器，也可能存在大量漏洞：虽然客户端和服务器之间的通信路径可能已加密，但不能保证客户端计算机不会受到恶意软件的破坏。 这些漏洞使得信任使用敏感数据客户端计算机具有一定危险性。但是，SGX的中的“远程证明”高级功能可以显着提高提供给客户端的信任级别。 使用远程证明流程，客户端的安全区域（Enclave）可以向远程实体明它是可信的，并与该实体建立经过身份验证的通信通道。作为证明的一部分，客户端安全区证明以下内容： 它的身份 它尚未被篡改 它在启用了Intel SGX的正版平台上运行 它以最新的安全级别（也称为可信计算库（TCB）级别）运行 5.远程认证流程5.1 先决条件 为了利用英特尔认证服务（IAS）进行远程认证，英特尔要求独立软件供应商（ISV）从利用增强的隐私ID（EPID）的英特尔®SGX认证服务获取API密钥。 （生产服务器将继续支持较早的基于证书的身份验证，以最大程度地减少对现有客户的干扰，并且目前没有停产日期。） 可以选择使用可链接或不可链接的证明策略。 可链接策略允许ISV确定是否有多个证明请求来自同一平台。 这不会标识个人平台，但允许ISV确定多个请求是否源自同一平台。 向ISV分发服务提供商ID（SPID）及其API密钥。服务提供商在与IAS通信时将使用此ID。 5.2 客户端-服务器协议远程认证利用修改的Sigma协议来实现客户端与服务器之间的Diffie-Hellman密钥交换（DHKE）。从此交换中获得的共享密钥可由服务提供商用来加密要提供给客户端的密钥。 客户安全区能够导出相同的交换密钥，并使用它来解密密钥。 5.3 通讯顺序5.3.1 供应请求远程证明的第一步涉及客户端要求服务提供商提供密钥。 这通常是服务提供商应用为发出这样的请求而实现的特定API端点。 服务提供者通过发出质询来请求客户端证明自己，从而对此请求做出响应。 5.3.2 Msg0 (client to server)为了响应质询请求，客户端执行几个步骤来构造“远程证明”流的初始消息。 假设客户端的安全区域（Encalve）已经初始化，则不受信任的代码将执行以下步骤。 执行一个ECALL调用进入安全区域 在安全区中执行 调用sgx_ra_init() 将结果和DHKE上下文参数返回到不受信任的应用程序 调用sgx_get_extended_epid_group_id() 函数sgx_ra_init（）接受服务提供商的公钥作为参数，并为在远程认证期间发生的DHKE返回一个不透明的上下文 使用客户端不透明的上下文可提供重放保护。（这句我也没太懂，原文是‘Using a context that is opaque to the client provides replay protection.’） 公钥的格式由sgx_tcrypto.h中的sgx_ec25_public_t数据类型设置。 EC密钥表示为其x坐标和y坐标： 123456typedef struct _sgx_ec256_public_t&#123; uint8_t gx[SGX_ECP256_KEY_SIZE]; uint8_t gy[SGX_ECP256_KEY_SIZE];&#125; sgx_ec256_public_t; 服务提供商者的公钥应该被硬编码到安全区中，结合安全区的签名确保密钥不会被终端用户修改，使得安全区只能与预期的远程服务通信。 如果该安全区需要访问平台服务，则必须在证明序列中包括平台服务安全区（Platform Services Enclave，PSE）。 PSE是包含在英特尔SGX软件包中的体系结构安全区，可为受信任的时间和单调计数器提供服务。这些服务可用于在生成随机数期间进行重放保护，并用于安全地计算密钥有效的时间长度。 如果使用PSE，那么流程将会变成如下： 执行一个ECALL调用进入安全区域 在安全区中执行 sgx_create_pse_session() sgx_ra_init() sgx_close_pse_session() 将结果和DHKE上下文参数返回到不受信任的应用程序 调用sgx_get_extended_epid_group_id() 无论安全区是否使用平台服务，安全区编写器都应公开执行ECALL的包装函数sgx_ra_init()。 从sgx_ra_init()获得成功结果后，客户端接下来将调用sgx_get_extended_epid_group_id()以检索英特尔®增强隐私ID（Intel®EPID）的扩展组ID（GID）。 英特尔EPID是用于验证的匿名签名方案。 关于EPID的详细资料：英特尔SGX：EPID设置和证明服。 扩展的GID作为msg0的主体发送到服务提供商。 msg0的格式和来自服务器的响应的详细信息由服务提供商决定。 但是，服务提供商必须验证其接收的GID是否受支持，如果不支持，则中止认证过程。 英特尔证明服务仅对扩展GID支持零值。？？ Msg0和Msg1（5.3.3 Msg1）可以选择一起发送。 5.3.3 Msg1 (client to server)给定对msg0的成功响应，或者如果将msg0与msg1一起发送，则客户端调用sgx_ra_get_msg1() 函数来构造包含DHKE客户端公共密钥的msg1对象，并将其发送给服务提供商。 此方法的其他参数包括在上一步中获得的DHKE上下文和指向sgx_ra_get_ga() 存根函数的指针，用于计算客户端DHKE密钥。 当安全区开发人员在安全区定义语言（EDL）文件中链接sgx_tkey_exchange库中并导入sgx_tkey_exchange.edl时，SDK会自动生成此函数。 msg1结构如下表所示 Element Size Ga_x 32 bytes Ga_y 32 bytes Intel® EPID GID 4 bytes SGX SDK 在sgx_key_exchange.h中为 msg1 定义的数据结构如下所示: 123456typedef struct _ra_msg1_t&#123; sgx_ec256_public_t g_a; sgx_epid_group_id_t gid;&#125; sgx_ra_msg1_t; 5.3.4 Msg2 (server to client)从客户端收到msg1时，服务提供商将检查请求中的值，生成其自己的DHKE参数，并发送查询到IAS以获取客户端发送的Intel EPID GID的签名吊销列表（SigRL）。 为了处理msg1和生成msg2，服务提供者提供一下步骤： 使用P-256曲线生成随机EC密钥，即密钥G_b。 从G_a和G_b派生密钥派生密钥（KDK）： 使用客户端的公共会话密钥G_a和服务提供商的私有会话密钥（从步骤1获得）G_b计算共享密钥。 此操作的结果将是Gab的x坐标，表示为Gab_x 通过反转Gab_x的字节，将其转换为Little-endian字节顺序。 使用0x00字节的块作为密钥，以Gabx的小字节序形式执行AES-128 CMAC。 步骤 ii 和 iii 的结果就是KDK 通过对如下字节序列执行AES-128 CMAC，从KDK派生SMK： 10x01 || SMK || 0x00 || 0x80 || 0x00 使用KDK作为密钥。 请注意|| 表示连接，“SMK”是文字字符串（不带引号）。 确定应从客户端请求的引用类型（0x0表示不可链接，0x1表示可链接）。 请注意，这是服务提供商的政策决定，并且SPID必须与正确的引用类型相关联。 设置KDF_ID。 通常是0x1 使用服务提供者的EC秘钥计算以下内容的ECDSA签名： 1Gbx || Gby || Gax || Gay 使用SMK作为秘钥计算一下内容的AES-128 CMAC:1Gb || SPID || Quote_Type || KDF_ID || SigSP 查询IAS以获取客户端的Intel EPID GID的对应的SigRL。 msg2结构如下表所示： Element Size A Gb_x 32 bytes A Gb_y 32 bytes A SPID 16 bytes A Quote_Type 2 bytes (uint16_t) A KDF_ID bytes (uint16_t) A Sig(Gb_Ga)_x 32 bytes A Sig(Gb_Ga)_y 32 bytes CMAC_SMK(A) 16 bytes SigRL_Size 4 bytes (uint32_t) SigRL_data SigRL_Size bytes SGX SDK在sgx_key_exchange.h 中为msg2定义了数据结构如下： 123456789101112typedef struct _ra_msg2_t&#123; sgx_ec256_public_t g_b; sgx_spid_t spid; uint16_t quote_type; uint16_t kdf_id; sgx_ec256_signature_t sign_gb_ga; sgx_mac_t mac; uint32_t sig_rl_size; uint8_t sig_rl[];&#125; sgx_ra_msg2_t; 再次，请参阅Msg0部分中提到的Intel EPID文章资源，以获取有关SigRL的详细说明。 该服务提供商的公钥和SigRL信息被打包到msg2中，并响应于msg1请求发送给客户端。 5.3.5 Msg3 (client to server)在客户端，当收到msg2时，应用程序将调用sgx_ra_proc_msg2() 函数来生成msg3。 该调用执行以下任务： 验证服务提供商签名。 检查SigRL。 返回msg3，其中包含用于证明特定安全区的引用。 传递给sgx_ra_proc_msg2() 的两个参数是sgx_ra_proc_msg2_trusted 和sgx_ra_get_msg3_trusted。 这些是edger8r工具自动生成的函数的指针，这意味着安全区必须执行以下操作： 链接到受信任的服务库（Linux上为libsgx_tservice.a，Windows上为sgx_tservice.lib） 在encalve的EDL文件的trust部分中包括以下内容： 1234include &quot;sgx_tkey_exchange.h&quot;from &quot;sgx_tkey_exchange.edl&quot; import *; sgx_ra_get_msg2_trusted() 进行的部分处理是获取安全区引用。 引用包括使用平台的EPID密钥签名的当前运行安全区的加密哈希或度量。只有英特尔认证服务可以验证此签名。它还包含有关平台上平台服务区域（PSE）的信息，IAS也将对其进行验证。 msg3的结构如下表所示： Element Size CMAC_SMK(M) 16 bytes Ga_x 32 bytes Ga_y 32 bytes Ps_Security_Prop 256 bytes Quote (436 + quote.signature_len) bytes SGX SDK在sgx_key_exchange.h 定义的msg3的数据结构如下： 12345678typedef struct _ra_msg3_t&#123; sgx_mac_t mac sgx_ec256_public_t g_a; sgx_ps_sec_prop_desc_t ps_sec_prop; uint8_t quote[];&#125; sgx_ra_msg3_t; 引用的结构定义在sgx_quote.h： 1234567891011121314typedef struct _quote_t&#123; uint16_t version; &#x2F;* 0 *&#x2F; uint16_t sign_type; &#x2F;* 2 *&#x2F; sgx_epid_group_id_t epid_group_id; &#x2F;* 4 *&#x2F; sgx_isv_svn_t qe_svn; &#x2F;* 8 *&#x2F; sgx_isv_svn_t pce_svn; &#x2F;* 10 *&#x2F; uint32_t xeid; &#x2F;* 12 *&#x2F; sgx_basename_t basename; &#x2F;* 16 *&#x2F; sgx_report_body_t report_body; &#x2F;* 48 *&#x2F; uint32_t signature_len; &#x2F;* 432 *&#x2F; uint8_t signature[]; &#x2F;* 436 *&#x2F;&#125; sgx_quote_t; 5.3.6 Msg4 (server to client)在接收到客户端发送的msg3，服务提供者必须按顺序执行一下步骤： 验证msg3中的Ga与msg1中的Ga是否一致。 验证CMAC_SMK(M)。 验证报告数据的前32个字节是否与（Ga || Gb || VK）的SHA-256摘要匹配，其中|| 表示串联。 通过使用KDK作为密钥，对以下字节序列执行AES-128 CMAC，可以得出VK：10x01 || &quot;VK&quot; || 0x00 || 0x80 || 0x00 验证客户提供的证明证据。 从msg3中提取引用。 将引用提交给IAS，调用API函数以验证证明证据。 验证在报告响应中收到的签名证书。 使用签名证书验证报告签名。 如果在步骤3中成功验证了引用，请执行以下操作： 1)提取安全区以及PSE（如果提供）的证明状态。 检查安全区标识（MRSIGNER），安全版本和产品ID。 检查调试属性，并确保未设置（在生产环境中）。 决定是否信任安全区以及PSE（如果提供）。 派生会话密钥SK和MK，该密钥将用于在会话期间在客户端和服务器之间传输将来的消息。 客户端可以简单地调用sgx_ra_get_keys() ，但是服务器必须使用KDK作为密钥，通过对以下字节序列执行AES-128 CMAC来手动派生它们：12MK: 0x01 || &quot;MK&quot; || 0x00 || 0x80 || 0x00SK: 0x01 || &quot;SK&quot; || 0x00 || 0x80 || 0x00 生成msg4并发送给客户端。 验证证明证据要求服务提供商将引用提交给IAS并获得证明报告。 该报告由IAS报告签名私钥签名，服务提供商必须使用IAS报告签名公钥验证此签名。 报告本身包含响应标头和有效负载，有效负载包含安全区和PSE清单的证明状态。 值为“OK”表示该组件可以信任。 任何其他值表示该组件是不可信的，或者如果采取了某些操作（例如软件或BIOS更新），则该组件是可信的。 有关完整的详细信息，请参阅IAS API 文档。 ISV负责将这些状态消息传递给客户端。 如果证明状态不是“OK”，则IAS可以选择发送Platform Info Blob（PIB），服务提供商可以选择将其转发给客户端。 客户端可以将PIB传递给sgx_report_attestation_status() 函数，以获取有关故障的更多详细信息。 msg4的格式取决于服务提供商。 它至少必须包含： 飞地是否受信任。 如果提交了PSE清单，则是否信任PSE清单。 它可以包含： PIB（如果存在）。 提供给安全区的秘钥。 应该使用从KDK派生的密钥对所有密钥进行加密（请参阅msg2）。 安全区重新认证超时。 当前时间。 客户端需要信任的其他服务器的公钥。 以上所述的完整流程如下图所示： 未完待续！！！！"},{"title":"fabric1.4 新特性","date":"2019-11-03T10:21:35.000Z","path":"2019/11/03/fabric-newfeature/","text":"fabric v1.4版本是Fabric的第一个长期支持版本（LTS） 新特性1. 新增Raft排序服务Raft是一个基于etcd协议实现的崩溃容错的排序服务。Raft 遵循“leader 和 followers”模型，当一个领导者被选择的时候，它的决定会复制给所有的跟随者。Raft排序服务比起基于Kafka的排序服务更加容易启动和管理，同时，Raft的设计模式允许世界上的所有组织为去中心化的排序服务贡献自己的节点。 2. 可维护性和运营的改进目前越来越多的fabric联盟网络被用在了生产环境中，因此fabric的可维护性和可操作性变得更加重要，因此在1.4版本中对日志记录、运行状态检查和操作指标方面都做了对应改进。所以，1.4版本也是推荐在生产环境中使用的fabric发行版本。 操作服务：新的RESTful操作服务为操作者提供了三个服务，用于监控和管理peer节点和orderer节点操作： 2.1 日志相关/logspec/logspec端点允许操作者动态获取或者设置peer和orderer节点的日志等级，该端点就是传统的REST资源支持GET和PUT; 当操作服务接收到Get /logspec请求的时候，服务会响应一个包含当前日志说明的JSON内容： 1&#123;&quot;spec&quot;:&quot;info&quot;&#125; 当操作服务接收到Put /logspec请求的时候，服务将会读取请求主体作为JSON内容。该内容必须包含一个名为spec的单一属性： 1&#123;&quot;spec&quot;:&quot;chaincode&#x3D;debug:info&quot;&#125; 如果spec被成功激活，服务将会响应 204 “No Content”。如果出错，服务响应 400 “Bad Request”和错误内容： 1&#123;&quot;error&quot;:&quot;error message&quot;&#125; 2.2 健康监控 /healthz/healthz端点允许操作者和容器编排服务检查peer和orderer节点的存活和健康状态，该端点就是传统的REST资源支持GET请求。该实现主要为了与Kubernetes的存活探测模型所兼容，但可以在其它场景中使用。 当接收到一个Get /healthz请求的时候，操作服务会调用所有为该流程注册过的检查器(checker)，当所有检查器成功返回，操作服务才会响应 200 “OK” 和一个JSON主体： 1234&#123;&quot;status&quot;: &quot;OK&quot;,&quot;time&quot;: &quot;2009-11-10T23:00:00Z&quot;&#125; 如果存在一个或者多个健康检查器返回错误，则操作服务将响应 503 “Service Unavailable”和一个包含具体哪些健康检查器出错信息的JSON主体 12345678910&#123;&quot;status&quot;: &quot;Service Unavailable&quot;,&quot;time&quot;: &quot;2009-11-10T23:00:00Z&quot;,&quot;failed_checks&quot;: [&#123;&quot;component&quot;: &quot;docker&quot;,&quot;reason&quot;: &quot;failed to connect to Docker daemon: invalid endpoint&quot;&#125;]&#125; 在当前版本，注册的健康检查只是针对Docker，其它健康检查会在后续版本增强。 2.3 指标 metricsmetrics端点允许操作者利用Prometheus 从peer节点和orderer节点拉取操作指标。指标也可以被推送到StatsD。 peer和orderer中的一些构件会公开一些指标来帮助观察系统的行为。使得操作者和管理员可以更好了解系统是如何随着时间推移而执行的。 Fabric提供两种公开指标的方式： 基于”Prometheus”的拉取(pull)模型和基于”StatsD”的推送(push)模型 2.3.1 Prometheus典型的Prometheus部署通过从由检测目标公开的HTTP端点请求它们来获取指标。由于Prometheus负责请求度量指标，因此它被认为是一个拉取系统。 peer节点通过配置公开 /metrics端点。通过在core.yaml中的metrics部分设置metrics provider为prometheus。 12metrics: provider: prometheus orderer节点通过配置公开 /metrics端点。通过在orderer.yaml中的Metrics部分设置metrics provider为prometheus。 12Metrics: Provider: prometheus 2.3.2 StatsDStatsD是一个简单的统计数据聚合守护进程。指标被发送到statsd守护进程，在那里它们被收集、聚合并推送到后端以进行可视化和警报。由于该模型要求被检测的进程将指标数据发送到StatsD，因此这被认为是一个推送系统。 peer通过在core.yaml文件中的metrics部分将metrics provider设置为statsd,将指标发送给StatsD。statsd子部分必须配置StatsD进程的地址，使用的网络类型tcp或者udp，发送指标的频率。可以指定一个可选前缀，以帮助区分指标的来源–例如，区分来自独立peer节点的指标–这些指标将被添加到所有生成的指标中。 1234567metrics: provider: statsd statsd: network: udp address: 127.0.0.1:8125 writeInterval: 10s prefix: peer-0 orderer通过在orderer.yaml文件中的Metrics部分将metrics provider设置为statsd,将指标发送给StatsD。Statsd子部分必须配置StatsD进程的地址，使用的网络类型tcp或者udp，发送指标的频率。可以指定一个可选前缀，以帮助区分指标的来源。 1234567Metrics: Provider: statsd Statsd: Network: udp Address: 127.0.0.1:8125 WriteInterval: 30s Prefix: org-orderer 现有可以获取的指标以及含义可以参考指标附录 3. 私有数据加强私有数据特性是从Fabric1.2版本开始出现的，1.4版本首次出现2个新特性： Reconciliation(这个不知道用中文要怎么翻译，原本意思是“和解”，但放这里不太对的样子)：允许添加到私有数据集的组织成员获取他们现在有权获得的以前交易的私有数据。 客户端访问控制可以根据客户端组织集合成员资格自动在链码中强制执行访问控制，而不必编写特定的链码逻辑。 4. 节点组织单元（Node OU）支持从v1.4.3开始，现在支持将节点OU用于admin和orderer身份分类（扩展了对client和peer的现有节点OU支持）。这些“组织单元”允许组织根据其x509证书的OU将身份进一步分类为管理员和订购者。"},{"title":"hexo博客转移","date":"2019-11-03T04:37:54.000Z","path":"2019/11/03/move-env/","text":"背景原来本菜鸡就是使用hexo来搭建自己的博客，但是最近因为换了电脑，所以需要将我自己的hexo项目转移到新的电脑中，有没有一种简单又方便的方法呢，以下就是本人亲测有效的一种最简单的方法。 方法步骤环境准备安装git客户端 git安装完成之后记得配置好自己对应账号信息 安装nodeJS 安装hexo1npm install hexo-cli -g 旧hexo项目源文件转移将原本电脑中的hexo项目中的源文件转移到新的电脑上，主要有以下文件和文件夹,本次转移到新文件夹harlanBlog： 12345scaffolds&#x2F;source&#x2F;themes&#x2F;package.json_config.yml 新hexo项目安装进入 harlanBlog 目录，安装hexo模块 12npm installnpm install hexo-deployer-git --save &#x2F;&#x2F;文章部署到git 以下命令参考其它博客，但本次转移没有使用 12pm install hexo-generator-feed --save &#x2F;&#x2F; RSS 订阅npm install hexo-generator-sitemap --save &#x2F;&#x2F; 站点地图 本地测试1hexo s 本地运行，访问本地4000端口，查看博客 部署并发布123hexo cleanhexo g hexo d 转移成功，哈哈，成果就是现在能看到这篇博文。"},{"title":"利用softEther VPN远程访问内部网络","date":"2019-11-02T07:12:46.000Z","path":"2019/11/02/softEther/","text":"利用 softEther VPN 进行远程访问作者: whr 使用场景和前提条件 内部网络受到保护，无法直接在内部网络中的主机中直接部署VPN server（搭建完无法连接到该server） 用户需要从外部网络远程访问内部网络中的资源，如主机或打印机等等 对内部网络中的某台主机拥有管理权限 有一台暴露在互联网中的主机 内部网络中的主机可以直接访问互联网 比如 学生于校外访问校园网资源 远程办公 管理家庭局域网设备 举个栗子这里通过一个例子，描述如何通过一步步的操作，利用softEther VPN 套件实现远程访问。 一个安全的网络（192.168.1.0/24），它受到防火墙和NAT的保护，无法从Internet访问，但是可以通过防火墙或NAT代理访问Internet上的网站。该网络中， IP地址为 192.168.1.111 的一台打印机，IP地址为 192.186.1.222 的一台主机H。一台暴露在Internet的主机S，IP地址为 125.111.111.111。 目标 通过构建主机S和主机H所在内部网络的级联网络，用户可以通过连接主机S所创建的VPN，实现对内部网络（192.168.1.0/24）中的资源的访问。 开始你的表演总体上整个任务的关键位置所运行的SoftEther VPN组件如下图所示 1、在主机S上安装搭建VPN server连接到 主机S ，将SoftEther VPN Server 组件下载到本地。组件选择地址根据实际运行环境，选择适当的版本。这里我选择的是Linux 系统，CPU选择的是**Intel x64 / AMD64 (64bit)**。 拿到下载地址后，使用wget命令进行下载，： 12345678910# 下载softether-vpnserver到本地wget https://github.com/SoftEtherVPN/SoftEtherVPN_Stable/releases/download/v4.30-9696-beta/softether-vpnserver-v4.30-9696-beta-2019.07.08-linux-x64-64bit.tar.gz#解压tar zxvf softether-*server*.tar.gzcd vpnserver/# 这里面有一个隐藏的文件.install.sh，运行它。[vpnserver]# ./.install.sh# 一路Yes，Agree默认即可 查看下载的文件进入对应文件夹运行安装脚本进行默认配置 安装完成后进入 12345678910111213141516171819202122232425262728293031# 启动vpnserver[vpnserver]# ./vpnserver start# 进行vpn的初始配置[vpnserver]# ./ vpncmdBy using vpncmd program, the following can be achieved.1. Management of VPN Server or VPN Bridge2. Management of VPN Client3. Use of VPN Tools (certificate creation and Network Traffic Speed Test Tool)Select 1, 2 or 3:# 选择1 回车Hostname of IP Address of Destination:# 回车If connecting to the server by Virtual Hub Admin Mode, please input the Virtual Hub name.If connecting by server admin mode, please press Enter without inputting anything.Specify Virtual Hub Name:# 回车Password:# 回车VPN Server&gt;ServerPasswordSet# 输入 ServerPasswordSetServerPasswordSet command - Set VPN Server Administrator PasswordPlease enter the password. To cancel press the Ctrl+D key.# 设置你的服务器管理密码Password: ******#这里输入管理密码Confirm input: ******#确认密码 至此，主机S上的vpnserver的安装和初步的配置就完成了，后面将介绍使用SoftEther VPN Server Manager 对其进行进一步的配置。 2、在主机H上安装搭建VPN Bridge连接到 主机H ，将SoftEther VPN Bridge 组件下载到本地。这里就不贴图了，具体和下载vpnserver一样，换成vpnbridge。下载地址 根据实际运行环境，选择适当的版本。这里我选择的是Linux 系统，CPU选择的是**Intel x64 / AMD64 (64bit)**。使用wget 命令进行下载，安装，初步配置也都相近： 12345678910111213141516171819202122232425262728293031323334353637383940# 下载softether-vpnbridge到本地wget https://github.com/SoftEtherVPN/SoftEtherVPN_Stable/releases/download/v4.30-9696-beta/softether-vpnbridge-v4.30-9696-beta-2019.07.08-linux-x64-64bit.tar.gz#解压tar zxvf softether-*bridge*.tar.gzcd vpnserver/# 这里面有一个隐藏的文件.install.sh，运行它。[vpnbridge]# ./.install.sh# 一路Yes，Agree默认即可[vpnbridge]# ./vpnbridge start[vpnbridge]# ./vpncmd...By using vpncmd program, the following can be achieved.1. Management of VPN Server or VPN Bridge2. Management of VPN Client3. Use of VPN Tools (certificate creation and Network Traffic Speed Test Tool)Select 1, 2 or 3: 1# 输入1Specify the host name or IP address of the computer that the destination VPN Server or VPN Bridge is operating on.By specifying according to the format &#x27;host name:port number&#x27;, you can also specify the port number.(When the port number is unspecified, 443 is used.)If nothing is input and the Enter key is pressed, the connection will be made to the port number 8888 of localhost (this computer).Hostname of IP Address of Destination:#回车If connecting to the server by Virtual Hub Admin Mode, please input the Virtual Hub name.If connecting by server admin mode, please press Enter without inputting anything.Specify Virtual Hub Name:#回车Connection has been established with VPN Server &quot;localhost&quot; (port 443).You have administrator privileges for the entire VPN Server.VPN Server&gt;ServerPasswordSetServerPasswordSet command - Set VPN Server Administrator PasswordPlease enter the password. To cancel press the Ctrl+D key.Password: ******#这里输入管理密码Confirm input: ******#确认密码The command completed successfully. 3、配置主机S上的vpnserver这里需要找了一台windows的机子，因为SoftEther提供了一款SoftEther VPN Server Manager的图形管理器，进行蛇者比较方便。要求就是最好在内网中，方便连接主机H，同时也能连接主机S。将SoftEther VPN Server Manager for Windows 图形组件下载到本地。下载地址 运行SoftEther VPN Server Manager，点击设置 填入设置名（这个随意），主机名填入主机S的IP地址，端口采用默认的443，代理类型选择直接TCP/IP连接（无代理），选中服务端管理模式并填入前面设置的vpnserver管理密码，点击确定。如果你在前面没有设置管理密码，在连接的时候将也提示你设置密码。 勾选远程访问VPN Server (R)，点击下一步后提示确认初始化，选择 是。 为你的vpnserver设置一个名字，这里输入VPN，点击确定。 动态DNS功能，不用管，直接无视选择退出。 IPsec/L2TP 设置，勾选启用L2TP服务器功能，并设置IPsec预共享秘钥。这一步是为了后面我们可以用手机或者PC自带的VPN工具进行连接。 VPN Azure 云，勾选禁用，点击确定。 创建一个用户来接受VPN连接，点击创建用户。 填入相关信息，验证类型选择密码验证，并在密码验证设置中填入密码。 我们这里需要创建两个账号，分别为user1和user2，一个用于主机H上的VPN bridge，一个用于用户在外网的状态下登录VPN。 点击关闭进入下一步。 点击管理HUB。 点击虚拟NAT和虚拟DHCP服务器。 点击启用SecureNAT，这一步很关键。 确定启用SecureNAT。 点击关闭。 至此，我们对于主机S上的VPN server的配置就完成了，接下来连接到主机H上的vpn bridge进行配置。 4、配置主机H上的vpnbridge同样是回到SoftEther VPN Server Manager主界面，点击新设置，填入VPN bridge的IP地址，这里是 192.168.1.222，如果前面在初步配置的时候选择默认的话，端口选择5555，如果前面在初步配置的时候选择默认的话。并填入管理密码。（参考3-1,3-2） 勾选站到站 VPN Server 或 VPN Bridge，选择下一步。 设置本地网桥。这里如果你有多张网卡的话，要选择你想级联出去网段所在的网卡。这里我想级联192.168.1.0/24网段，我选择配置为该网段地址的网卡，eth0。不清楚对应网卡的可以在控制台运行ifconfig命令查看。 回到管理器面板，点击管理虚拟HUB，点击虚拟NAT和虚拟DHCP服务器，启用 SecureNAT。 回到管理器面板，点击管理虚拟HUB，选择管理级联连接。 填写连接设置名(自由设置)，填写vpnserver的地址，即主机S的IP地址，端口号选择443。只要你的地址和端口填写正确，并且前面配置无误，这里虚拟HUB名的下拉列表就能找到我们之前创建的虚拟HUB “VPN”。勾选无代理，选择认证类型为标准密码验证，并填写用户名密码。这里使用创建的用户user1。点击确定。 进入到级联管理界面，选中我们刚刚创建的连接，点击在线。 发现该装填已由离线变成在线。 至此，我们在对主机H的vpn bridge的配置也大功告成。此时主机S与主机H逻辑上已经是同属一个网络，主机S可以直接访问内网192.168.1.0/24网络。所以下一步，我们只要连接到主机S的VPN，我们也就可以和主机S一样，直接访问内网192.168.1.0/24网络的资源了。 5. 用户配置L2TP/IPsec VPN IOS端设置。 Android端设置。 ————————————————连接时填入用户名密码即可。 Windows端设置。 连接有问题的时候请检查一下主机S的防火墙和安全策略设置。请开启L2TP必要的端口：UDP 500、4500、1701。 完结撒花"},{"title":"论文解读（1）BLA——基于区块链的认证","date":"2019-10-26T13:38:17.000Z","path":"2019/10/26/paperBLA/","text":"本篇博文分享来自期刊《IEEE INTERNET OF THINGS JOURNAL》中的一篇论文《BLA: Blockchain-Assisted Lightweight Anonymous Authentication for Distributed Vehicular Fog Services》针对分布式车辆雾服务的区块链辅助的轻量级匿名认证 一.背景1. 概念车载自治网络（VANET）是移动自治网络（MABET）的一部分，包括移动车辆和路边单元（RSUs）。每辆车都配置了一个车载单元（OBU）和一组传感器。 2.问题及可采取方式由于车辆的移动性，所以对于车辆雾服务（VFSs）来说需要跨分布式的数据中心，这样跨数据中心的认证也是在这个过程中不可避免的问题。 VAENTs依赖于云计算服务来进行通信，计算以及存储。而联网的车辆逐渐增多且不断增长的移动性要求服务的低延时和不可中断。这给当前云计算带来很大挑战。因此，车辆雾计算（VFC）被提出来提高通信效率和计算能力以适应最新的车辆应用。 3. 现状VFC被认为是对延迟敏感的应用来说是非常有益的技术之一，是对于高速移动车辆的一种理想的技术。 VFS基本安全和性能要求： 1）车辆身份认证与隐私 每辆车访问VFS必需经过认证，是后面授权决策的基础。同时必须保证在认证过程车辆的身份不会被暴露，确保车辆用户的隐私。 2）实时限制 另一方面，为了适应车辆的快速移动，要求认证是轻量级的。 现有的认证机制及缺点： 应用技术： 对称加密、PKI、基于身份的签名（IBS）、无证书签名、群签名； 缺点： 依赖于管理中心来提前创建与车辆间的信任关系，当车辆移动到新数据中心的时候，信任关系将会失效。 解决存在缺点的方式： 提出跨数据中心、跨地区、跨域的认证机制，存在以下问题： 要求在OBUs、RSUs和信任机构之间多次交互，造成高通信延时 数据库由单个管理员管理，无法抵抗篡改攻击 二. 解决方案（论文贡献） 实现灵活的跨数据中心认证。这里的灵活指的是车辆在移动到一个新的数据中心时，自身可以决定是否重新认证或者只是直接发送一个VFS请求。 为了保护车辆隐私实现匿名。车辆可以自主决定更换自己伪名的时间和频率。 提出的认证机制BLA是轻量级的。将密码和区块链技术结合起来，以消除车辆和服务管理器(SMS)之间的交互性。在访问VFS之前，驾驶着的车辆只需要发送一个消息，该消息可以是认证消息或VFS请求消息。这可以显著缩短认证的时间。此外，应用区块链技术还消除了在用户认证过程中SMs之间的通信。因为所有SMs的记录被同步地更新。 由于公共账本是由所有的SMs所维护，所以BLA可以有效抵抗数据库篡改攻击。 三. 方案实现3.1 系统模型 全称 缩写 意义 Audit Department AD 审计机构 service manager SM 服务管理 on-board unit OBU 车子啊单元 roadside unit RSU 路边单元 vehicular fog computing VFC 车辆雾计算 vehicular fog services VFS 车辆雾服务 vehicular fog datacenter VFD 车辆雾数据中心 Witness Peer WP 见证节点 AD (Audit Department):作为一个完全可信的机构，负责OBUs（车载单元）和SMs（服务管理）的注册，并追溯违法车辆 SM：一个区域的服务管理者需要在搭建系统之前就在AD处进行注册，SM主要负责管理所有的VFDs并对其管理区域的OBUs进行认证。每个SM维护一个包含所有车辆访问记录的公共账本。公共账本智能由AD、SMs和WPs所访问。 WP(Witness Peer): WP负责通过共识算法把认证结果写入公共账本的节点，所有的WPs和SMs共同组成了联盟区块链 RSU： 是VFD的管理者并为合法的OBUs提供VFS服务。只属于由一个SM所管理的地区。 OBU： OBU是VFS的用户，配置有计算和通信功能，包括内嵌的计算机、无线网络接口、GPS接收器、导航系统、数字地图等等。在访问VFS之前需要先在AD处注册。 联盟区块链网络（CBN）：由所有地区的SMs和WPs组成。 3.2 目标 保密性： 确保传输的数据无法被敌手解密 完整性： 确保传输的数据无法被敌手篡改 匿名性： 允许所有车辆使用自己定义的伪名并且在访问VFS的过程中，车辆可以通过重新认证自己来改变自己的伪名。使得敌手无法追踪或者计算车辆。 非交互性： 车辆只需要在访问VFS之前发出一个认证或者访问VFS的信息即可，无需其它信息。 可追踪性： 保证AD可以追踪非法车辆并拒绝它们对VFS的访问。 无法抵赖性： 当一辆违法车辆被报告是，则该车辆无法抵赖其错误行为。 轻量性：确保计算与通信开销较低。 3.3 具体实现步骤3.3.1 初始化设置系统参数，包括决定系统安全的大素数、哈希算法、AD的公私钥对。最后保留AD私钥。 3.3.2 注册注册阶段包括SM和OBU的注册 SM注册 随机选择一个整数sk1作为私钥的第一部分，根据这部分私钥计算出公钥pk1。然后把pk1和自己身份id用AD公钥加密发送给AD AD将从SM收到的加密信息用自身私钥解密，在身份检查过后，随机选择一个整数d，并根据这个整数计算出一对公私钥对pk2和sk2，然后通过安全通道发送给SM SM收到AD发来的pk2和sk2，将sk2提取出来与sk1组成完整的私钥，将pk2提取出与pk1组成完整的公钥，同时SM能够通过计算获取sk2是否可靠。 OBU注册：与SM注册过程类似，在此不再赘述 3.3.3 认证 这个阶段只要通过SMs来认证OBUs。在认证之后，SMs将认证结果广播出去，认证结果会在共识阶段由WP利用共识机制写入公共账本（区块链）中，当一个行驶着的OBU首次访问VFS时，需要执行以下步骤： 计算s： 计算hi R C 计算xi 和 k个系数 计算Yi和Vi OBUa将密文发送给离它最近的RSU，假设为RSUm RSUm接收到密文然后转发个区域管理者，假设为SMn 在接收到密文之后SMn进行以下操作： 根据自己身份计算以下数值： 计算R’并恢复原始数据和签名 从恢复出来的数据中获取OBUa的身份，如果对应公钥没在撤销列表，则进行以下计算： 验证以下等式是否成立： 3.3.4 共识 通过x=(heightmodk)+1来决定消息发送者(speaker)，其中height代表当前区块高度。由于选择是消息发送者不会影响共识结果，所以允许同一个消息发送者主持几轮共识过程来节约选择消息发送者的时间。 任何SM可以广播经过签名的认证结果给所有的WPs。 所有的WPs着上一步发送出来的认证结果数据并存在各自的内存中。 经过结块周期t时间之后，已经广播的认证结果组成一个新的区块，由消息发送者发送给其它WPs，要求WPs进行投票并签名。 接收到消息发送者发出的提案请求之后，WPs进行签名并回复。 任何WP在接收到至少(k−f)节点的签名区块时，都会达到共识并发布完整的块。如果签名的区块的数目达不到(k−f)，则将执行下一轮共识。这里，f=(k−1)/3表示系统中允许的最大错误WP数，例如，WP有网络故障。 任何WP在接收到完整的区块之后，从自身内存中删除包含在该区块中的认证结果并开始下一轮的共识。 3.3.5 服务交付在这一个阶段，当一个OBU移动到一个新的RSU的VFD时，可以选择不进行重新认证，过程如下： 当OBU驶入另一个RSU的服务范围时，会提交它的访问请求给RSU，请求包括伪名和时间戳的签名，伪名，时间戳。 同样，RSU会将访问请求转发给它的区域管理者SM SM首先查找自身的本地数据库看是否存在OBU的公钥，如果不存在，则到公共账本中去寻找对应信息。如果OBU的公钥没有在撤销列表当中的话，SM会验证OBU请求中的签名信息，如果认证通过且时间戳有效，SM会直接通知RSU响应OBU的服务请求。否则，SM会拒绝提供服务。 在这整个过程中如果非法车辆被AD所记录，AD会到公共账本中寻找该车辆的身份并通知所有SMs该非法车辆的公钥是无效的并将其添加到撤销列表中。 四. 模拟实验结果4.1 实验环境 4.2 时间开销 认证阶段 共识阶段4.3 在4,7,10个SM的基础下，认证一个请求所需平均时间：RSU逐渐增加和车辆到达时间间隔逐渐增加"},{"title":"为通道添加新的组织（续）","date":"2019-10-24T05:12:54.000Z","path":"2019/10/24/addorg2/","text":"本篇博文为上篇博文“为通道添加新的组织”的可选部分。 更新通道配置包含Org3锚节点因为Org1和Org2已经在通道配置中定义了锚节点，所以Org3的peer节点可以与Org1和Org2的peer节点建立gossip连接。同样，新添加的组织如Org3也应该在通道配置中定义自己的锚节点，让其它组织的新peer可以直接发现一个Org3的peer。 从Org3-CLI继续，为了定义一个Org3锚节点对通道配置进行更新，该过程与上次的配置更新相似。 1.获取最新配置区块：1peer channel fetch config config_block.pb -o orderer.example.com:7050 -c $CHANNEL_NAME --tls --cafile $ORDERER_CA 结果如下： 12345root@e6a67979d990:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# peer channel fetch config config_block.pb -o orderer.example.com:7050 -c $CHANNEL_NAME --tls --cafile $ORDERER_CA2019-10-24 02:55:14.866 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized2019-10-24 02:55:14.883 UTC [cli.common] readBlock -&gt; INFO 002 Received block: 72019-10-24 02:55:14.891 UTC [cli.common] readBlock -&gt; INFO 003 Received block: 52019-10-24 02:55:14.892 UTC [channelCmd] fetch -&gt; INFO 004 Retrieving last config block: 5 2. 文件转换与配置添加configtxlator将.pb文件转化为.json文件，同时jq工具去掉头部，元数据和签名。 1configtxlator proto_decode --input config_block.pb --type common.Block | jq .data.data[0].payload.data.config &gt; config.json 123root@e6a67979d990:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# configtxlator proto_decode --input config_block.pb --type common.Block | jq .data.data[0].payload.data.config &gt; config.jsonroot@e6a67979d990:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# lsconfig.json config_block.pb crypto mychannel.block scripts 现在的config.json代表着将要被更新的最新的通道配置，再次使用jq工具更新配置JSON文件，添加Org3锚节点。 1jq &#39;.channel_group.groups.Application.groups.Org3MSP.values +&#x3D; &#123;&quot;AnchorPeers&quot;:&#123;&quot;mod_policy&quot;: &quot;Admins&quot;,&quot;value&quot;:&#123;&quot;anchor_peers&quot;: [&#123;&quot;host&quot;: &quot;peer0.org3.example.com&quot;,&quot;port&quot;: 11051&#125;]&#125;,&quot;version&quot;: &quot;0&quot;&#125;&#125;&#39; config.json &gt; modified_anchor_config.json 123root@e6a67979d990:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# jq &#39;.channel_group.groups.Application.groups.Org3MSP.values +&#x3D; &#123;&quot;AnchorPeers&quot;:&#123;&quot;mod_policy&quot;: &quot;Admins&quot;,&quot;value&quot;:&#123;&quot;anchor_peers&quot;: [&#123;&quot;host&quot;: &quot;peer0.org3.example.com&quot;,&quot;port&quot;: 11051&#125;]&#125;,&quot;version&quot;: &quot;0&quot;&#125;&#125;&#39; config.json &gt; modified_anchor_config.jsonroot@e6a67979d990:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# lsconfig.json config_block.pb crypto modified_anchor_config.json mychannel.block scripts 将.json文件转换为 .pb文件，并计算增量： 123configtxlator proto_encode --input config.json --type common.Config --output config.pbconfigtxlator proto_encode --input modified_anchor_config.json --type common.Config --output modified_anchor_config.pbconfigtxlator compute_update --channel_id $CHANNEL_NAME --original config.pb --updated modified_anchor_config.pb --output anchor_update.pb 12345root@e6a67979d990:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# configtxlator proto_encode --input config.json --type common.Config --output config.pbroot@e6a67979d990:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# configtxlator proto_encode --input modified_anchor_config.json --type common.Config --output modified_anchor_config.pbroot@e6a67979d990:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# configtxlator compute_update --channel_id $CHANNEL_NAME --original config.pb --updated modified_anchor_config.pb --output anchor_update.pbroot@e6a67979d990:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# lsanchor_update.pb config.json config.pb config_block.pb crypto modified_anchor_config.json modified_anchor_config.pb mychannel.block scripts 将anchor_update.pb转化为anchor_update.json: 1configtxlator proto_decode --input anchor_update.pb --type common.ConfigUpdate | jq . &gt; anchor_update.json 将更新封装在信封信息（envelope message）中，重新添加之前丢弃的头部,输出anchor_update_in_envelope.json文件： 1echo &#39;&#123;&quot;payload&quot;:&#123;&quot;header&quot;:&#123;&quot;channel_header&quot;:&#123;&quot;channel_id&quot;:&quot;mychannel&quot;, &quot;type&quot;:2&#125;&#125;,&quot;data&quot;:&#123;&quot;config_update&quot;:&#39;$(cat anchor_update.json)&#39;&#125;&#125;&#125;&#39; | jq . &gt; anchor_update_in_envelope.json 将anchor_update_in_envelope.json转化为anchor_update_in_envelope.pb 1configtxlator proto_encode --input anchor_update_in_envelope.json --type common.Envelope --output anchor_update_in_envelope.pb 结果： 123root@e6a67979d990:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# lsanchor_update.json anchor_update_in_envelope.json config.json config_block.pb modified_anchor_config.json mychannel.blockanchor_update.pb anchor_update_in_envelope.pb config.pb crypto modified_anchor_config.pb scripts 最后进行签名并提交更新，因为这只是对Org3的更新，所以只需要Org3在更新签名即可。由于当前环境身份为Org3身份，因此不需要切换身份。 1peer channel update -f anchor_update_in_envelope.pb -c $CHANNEL_NAME -o orderer.example.com:7050 --tls --cafile $ORDERER_CA 123root@e6a67979d990:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# peer channel update -f anchor_update_in_envelope.pb -c $CHANNEL_NAME -o orderer.example.com:7050 --tls --cafile $ORDERER_CA2019-10-24 03:24:29.270 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized2019-10-24 03:24:29.324 UTC [channelCmd] update -&gt; INFO 002 Successfully submitted channel update orderer接收得到配置更新请求，添加一个配置更新区块。当所有peer接收到该区块，则会处理配置更新。 查看其中一个容器日志，当处理一个新区块中的配置交易时，可以看到gossip重新建立连接，代表配置更新已经成功应用了 1docker logs -f peer0.org1.example.com 12345678mit&#x3D;4ms) commitHash&#x3D;[742a4724235b86378598f9f77115dee0bac62859d79062a43de1a151b43cef81]2019-10-24 03:24:29.329 UTC [gossip.privdata] StoreBlock -&gt; INFO 2e1 [mychannel] Received block [8] from buffer2019-10-24 03:24:29.370 UTC [gossip.gossip] JoinChan -&gt; INFO 2e2 Joining gossip network of channel mychannel with 3 organizations2019-10-24 03:24:29.370 UTC [gossip.gossip] learnAnchorPeers -&gt; INFO 2e3 Learning about the configured anchor peers of Org2MSP for channel mychannel : [&#123;peer0.org2.example.com 9051&#125;]2019-10-24 03:24:29.370 UTC [gossip.gossip] learnAnchorPeers -&gt; INFO 2e4 Learning about the configured anchor peers of Org3MSP for channel mychannel : [&#123;peer0.org3.example.com 11051&#125;]2019-10-24 03:24:29.370 UTC [gossip.gossip] learnAnchorPeers -&gt; INFO 2e5 Learning about the configured anchor peers of Org1MSP for channel mychannel : [&#123;peer0.org1.example.com 7051&#125;]2019-10-24 03:24:29.370 UTC [gossip.gossip] learnAnchorPeers -&gt; INFO 2e6 Anchor peer with same endpoint, skipping connecting to myself2019-10-24 03:24:29.413 UTC [committer.txvalidator] Validate -&gt; INFO 2e7 [mychannel] Validated block [8] in 83ms 到目前为止，已经成功提交两个配置更新操作，包括添加Org3到通道中和为Org3定义锚节点。"},{"title":"为通道添加新的组织","date":"2019-10-23T03:07:23.000Z","path":"2019/10/23/addorg1/","text":"1. 切换路径并关闭已存在网络1cd &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;first-network&#x2F; 执行通道配置更新并不是必需要关闭已有的网络。本次教程只是为了从初始状态开始才将原有网络关闭。 1.&#x2F;byfn.sh down 2.生成新的网络12.&#x2F;byfn.sh generate.&#x2F;byfn.sh up 3.添加新组织Org33.1 利用脚本添加新组织Org31.&#x2F;eyfn.sh up 如果顺利运行，你可以看到以下内容： 12345678&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; All GOOD, EYFN test execution completed &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; _____ _ _ ____ | ____| | \\ | | | _ \\ | _| | \\| | | | | | | |___ | |\\ | | |_| | |_____| |_| \\_| |____&#x2F; 3.2 手动添加新组织Org3因为上面步骤已经使用了eyfn.sh脚本，因此需要关闭网络，删除所有容器，并撤销添加Org3的操作。 1.&#x2F;eyfn.sh down 网络关闭之后，再次将其恢复 12.&#x2F;byfn.sh generate.&#x2F;byfn.sh up 此时网络恢复到执行eyfn.sh脚本之前的状态 3.2.1 生成Org3的加密材料进入org3-artifacts目录 1cd org3-artifacts&#x2F; 123[root@localhost first-network]# cd org3-artifacts&#x2F;[root@localhost org3-artifacts]# lsconfigtx.yaml org3-crypto.yaml 生成加密材料 1cryptogen generate --config&#x3D;.&#x2F;org3-crypto.yaml 12[root@localhost org3-artifacts]# cryptogen generate --config&#x3D;.&#x2F;org3-crypto.yamlorg3.example.com 该命令读取加密材料生成所需要的yaml文件，并利用cryptogen工具为Org3的一个CA和两个与之绑定的peer节点生成密钥和证书。生成的材料放在当前目录的crypto-config文件夹中. 利用configtxgen来以JSON的格式打印Org3指定配置材料，配置让configtxgen在当前目录寻找configtx.yaml文件 1export FABRIC_CFG_PATH&#x3D;$PWD &amp;&amp; configtxgen -printOrg Org3MSP &gt; ..&#x2F;channel-artifacts&#x2F;org3.json 该命令生成一个org3.json文件，存放在first-network目录下的channel-artifacts文件夹中。该文件包含Org3的策略定义和三个base64格式的证书：管理员用户证书，CA根证书和TLS根证书。该json文件会在后面的步骤中加入到通道配置中。 123[root@localhost first-network]# cd channel-artifacts&#x2F;[root@localhost channel-artifacts]# lschannel.tx genesis.block Org1MSPanchors.tx Org2MSPanchors.tx org3.json 最后将orderer的MSP材料复制到Org3的crypto-config目录下。orderer的TLS根证书允许Org3和网络排序节点的安全通信。 1cd ..&#x2F; &amp;&amp; cp -r crypto-config&#x2F;ordererOrganizations org3-artifacts&#x2F;crypto-config&#x2F; cp -r 代表拷贝文件夹 123[root@localhost first-network]# cd org3-artifacts&#x2F;crypto-config&#x2F;[root@localhost crypto-config]# lsordererOrganizations peerOrganizations 可以看到已经将orderer的MSP材料复制到对应位置。 3.2.2 CLI环境准备更新过程利用配置转换工具：configtxlator。该工具提供独立于SDK的无状态REST API。同时提供了CLI来简化Fabric网路中的配置工作。该工具作用是在不同等效数据表示形式/格式之间轻松转换（在本例子中，在protobufs和json格式之间转换）。另外，该工具可以基于两个通道配置之间的差异来计算配置更新事务。 进入容器并配置ORDERER_CA 和 CHANNEL_NAME的值 12docker exec -it cli bashexport ORDERER_CA&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem &amp;&amp; export CHANNEL_NAME&#x3D;mychannel 查看是否正确设置对应变量值 1echo $ORDERER_CA &amp;&amp; echo $CHANNEL_NAME 123root@f7d186065b85:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# echo $ORDERER_CA &amp;&amp; echo $CHANNEL_NAME&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pemmychannel 这样的变量设置方式是临时的，一旦退出cli容器，重新进入时就需要再次重新设置。 3.2.3 获取配置获取通道mychannel最新的配置区块。之所以要获取最新的配置区块是因为配置元素是版本化的。可以避免重复的配置更改，同时有助于确保并发性（当需要从通道删除一个组织的时候，例如在一个新组织被添加到通道中之后，版本控制有助于防止同时将两个组织都删除了，而是保证仅仅删除想要删除的组织） 1peer channel fetch config config_block.pb -o orderer.example.com:7050 -c $CHANNEL_NAME --tls --cafile $ORDERER_CA 该命令保存二进制protobuf通道配置块到config_block.pb。注意此处的名称和文件后缀选择是随意的，但是建议遵循一个约定，该约定既能表示对象类型也能体现对象的编码（protobuf 或者 json）格式。 12345root@f7d186065b85:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# peer channel fetch config config_block.pb -o orderer.example.com:7050 -c $CHANNEL_NAME --tls --cafile $ORDERER_CA2019-10-22 11:17:44.424 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized2019-10-22 11:17:44.436 UTC [cli.common] readBlock -&gt; INFO 002 Received block: 42019-10-22 11:17:44.438 UTC [cli.common] readBlock -&gt; INFO 003 Received block: 22019-10-22 11:17:44.438 UTC [channelCmd] fetch -&gt; INFO 004 Retrieving last config block: 2 从日志最后一行可以看出通道mychannel最近的配置块实际上是区块2，并不是创世区块。默认情况下该命令返回目标通道的最新区块，在本次示例中最新区块为第三个区块。因为脚本为两个组织在两个独立的通道更新交易中定义了锚节点。所以配置序列如下： 区块0：创世区块 区块1：Org1锚节点更新 区块2：Org2锚节点更新 3.2.3 配置文件格式转换与修改使用configtxlator工具将通道配置块解码为JSON格式（人类可读取和修改）。 同时必须将所有与我们要进行的更改无关的标题，元数据，创建者签名等剥离。 通过使用jq工具完成此任务： 1configtxlator proto_decode --input config_block.pb --type common.Block | jq .data.data[0].payload.data.config &gt; config.json 执行完毕生成一个简洁的JSON对象config.json作为后续配置更新的基准文件。 12root@f7d186065b85:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# lschannel-artifacts config.json config_block.pb crypto log.txt mychannel.block scripts 3.2.4 添加Org3加密材料再次使用jq工具追加Org3的配置定义Org3.json到通道的应用组字段中并将输出命名为modified_config.json。 1jq -s &#39;.[0] * &#123;&quot;channel_group&quot;:&#123;&quot;groups&quot;:&#123;&quot;Application&quot;:&#123;&quot;groups&quot;: &#123;&quot;Org3MSP&quot;:.[1]&#125;&#125;&#125;&#125;&#125;&#39; config.json .&#x2F;channel-artifacts&#x2F;org3.json &gt; modified_config.json 可以看到已经生成modified_config.json文件 12root@f7d186065b85:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# lschannel-artifacts config.json config_block.pb crypto log.txt modified_config.json mychannel.block scripts 此时。已经有两个JSON文件，分别是config.json和modified_config.json。初始文件只包含Org1和Org2的信息，而修改后的文件包含了三个组织的信息。此时，只需重新编码这两个JSON文件并计算增量即可。 将config.json转回protobuf格式，命名为config.pb 1configtxlator proto_encode --input config.json --type common.Config --output config.pb 将modified_config.json转回protobuf格式，命名为modified_config.pb 1configtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pb 查看对应文件是否生成 12root@f7d186065b85:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# lschannel-artifacts config.json config.pb config_block.pb crypto log.txt modified_config.json modified_config.pb mychannel.block scripts 利用configtxlator计算两个配置protobufs的增量，以下命令会输出一个新的protobuf名为org3_update.pb: 1configtxlator compute_update --channel_id $CHANNEL_NAME --original config.pb --updated modified_config.pb --output org3_update.pb 可以看到所需要文件已经生成 12root@f7d186065b85:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# lschannel-artifacts config.json config.pb config_block.pb crypto log.txt modified_config.json modified_config.pb mychannel.block org3_update.pb scripts 新生成的org3_update.pb 包含Org3的定义和指向Org1和Org2的高级指针。 在提交通道更新之前，我们需要执行最后的几步。 首先将 org3_update.pb 解码为可编辑的JSON格式，命名为org3_update.json 1configtxlator proto_decode --input org3_update.pb --type common.ConfigUpdate | jq . &gt; org3_update.json 12root@f7d186065b85:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# lschannel-artifacts config.json config.pb config_block.pb crypto log.txt modified_config.json modified_config.pb mychannel.block org3_update.json org3_update.pb scripts 在有解码后的org3_update.json文件之后，需要将其封装在信封消息之中。这一步会将我们先前删除的头部数据添加回来，封装完的文件命名为org3_update_in_envelope.json 1echo &#39;&#123;&quot;payload&quot;:&#123;&quot;header&quot;:&#123;&quot;channel_header&quot;:&#123;&quot;channel_id&quot;:&quot;mychannel&quot;, &quot;type&quot;:2&#125;&#125;,&quot;data&quot;:&#123;&quot;config_update&quot;:&#39;$(cat org3_update.json)&#39;&#125;&#125;&#125;&#39; | jq . &gt; org3_update_in_envelope.json 123root@f7d186065b85:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# lschannel-artifacts config.pb crypto modified_config.json mychannel.block org3_update.pb scriptsconfig.json config_block.pb log.txt modified_config.pb org3_update.json org3_update_in_envelope.json 最后再次利用configtxlator工具将org3_update_in_envelope.json转化为Fabric所需要的完整protobuf格式，命名为org3_update_in_envelope.pb: 1onfigtxlator proto_encode --input org3_update_in_envelope.json --type common.Envelope --output org3_update_in_envelope.pb 123root@f7d186065b85:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# lschannel-artifacts config.pb crypto modified_config.json mychannel.block org3_update.pb org3_update_in_envelope.pbconfig.json config_block.pb log.txt modified_config.pb org3_update.json org3_update_in_envelope.json scripts 3.2.5 签名并提交配置更新现在在CLI容器中已经有了org3_update_in_envelope.pb。但是在配置写入账本之前，必需要有来自Admin用户的签名，在已有通道应用组中修改策略设置为默认“MAJORITY”，即需要大多数现有的组织管理员的签名。因为目前只有Org1和Org2两个组织，所以需要这两个组织的签名。如果没有这两个签名，排序服务交易未能满足策略而拒绝交易。 Org1 Admin签名： 1peer channel signconfigtx -f org3_update_in_envelope.pb 12root@f7d186065b85:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# peer channel signconfigtx -f org3_update_in_envelope.pb2019-10-22 14:03:32.763 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized 在组织之间切换以签署配置事务（或执行其他任何操作）并不能反映真实的Fabric操作。单个容器永远不会安装整个网络的加密材料。而是需要将配置更新安全地带外传递给Org2管理员进行检查和批准。 切换到Org2环境变量 1234567export CORE_PEER_LOCALMSPID&#x3D;&quot;Org2MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;peers&#x2F;peer0.org2.example.com&#x2F;tls&#x2F;ca.crtexport CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;users&#x2F;Admin@org2.example.com&#x2F;mspexport CORE_PEER_ADDRESS&#x3D;peer0.org2.example.com:9051 发出更新命令，此时Org2 Admin的签名将会附加到此调用中。因此不需手动再次为protobuf签名。 1peer channel update -f org3_update_in_envelope.pb -c $CHANNEL_NAME -o orderer.example.com:7050 --tls --cafile $ORDERER_CA 122019-10-22 14:06:55.118 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized2019-10-22 14:06:55.164 UTC [channelCmd] update -&gt; INFO 002 Successfully submitted channel update 3.2.6 选择配置新加入的节点通过创世块进行引导，但是创世块中不包含通道配置更新中被新添加进去的组织。因此新节点无法利用gossip，因为在新节点获得添加组织到通道的配置交易前，无法验证其它节点从自己组织中转发过来的区块。新添加的节点必须进行以下配置（二选一）使得新的节点能够从排序服务中接收区块。 利用静态选举模式，将节点配置为组织领导12 CORE_PEER_GOSSIP_USELEADERELECTION&#x3D;falseCORE_PEER_GOSSIP_ORGLEADER&#x3D;true 所有添加到通道中的新节点配置必须相同 利用动态领导选举模式，配置节点使用领导选举12CORE_PEER_GOSSIP_USELEADERELECTION&#x3D;trueCORE_PEER_GOSSIP_ORGLEADER&#x3D;false 由于新添加组织中的节点无法形成成员视图，因此该配置是与静态模式相似的。因为每个节点在一开始的时候都会宣称自己是领导者。但是一旦它们获得添加组织到通道的配置交易更新，则组织只会有一个领导节点。所以如果最后希望组织节点利用领导选举则建议使用这种模式。 以上两种模式配置都是在first-network目录中的base文件夹下的peer-base.yaml文件中进行。以下截取可以配置部分： 12345678910111213141516171819peer-base: image: hyperledger&#x2F;fabric-peer:$IMAGE_TAG environment: - CORE_VM_ENDPOINT&#x3D;unix:&#x2F;&#x2F;&#x2F;host&#x2F;var&#x2F;run&#x2F;docker.sock # the following setting starts chaincode containers on the same # bridge network as the peers # https:&#x2F;&#x2F;docs.docker.com&#x2F;compose&#x2F;networking&#x2F; - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE&#x3D;$&#123;COMPOSE_PROJECT_NAME&#125;_byfn - FABRIC_LOGGING_SPEC&#x3D;INFO #- FABRIC_LOGGING_SPEC&#x3D;DEBUG - CORE_PEER_TLS_ENABLED&#x3D;true - CORE_PEER_GOSSIP_USELEADERELECTION&#x3D;true - CORE_PEER_GOSSIP_ORGLEADER&#x3D;false - CORE_PEER_PROFILE_ENABLED&#x3D;true - CORE_PEER_TLS_CERT_FILE&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;tls&#x2F;server.crt - CORE_PEER_TLS_KEY_FILE&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;tls&#x2F;server.key - CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;tls&#x2F;ca.crt working_dir: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer command: peer node start 3.2.7 将Org3加入通道以上步骤只是将Org3添加到Fabric网络中，但是此时Org3还没有进入任何通道 首先，启动Org3 的节点容器和一个Org3对应的CLI容器在first-network目录下： 1docker-compose -f docker-compose-org3.yaml up -d 1234567[root@localhost first-network]# docker-compose -f docker-compose-org3.yaml up -dCreating volume &quot;net_peer0.org3.example.com&quot; with default driverCreating volume &quot;net_peer1.org3.example.com&quot; with default driverWARNING: Found orphan containers (cli, peer0.org2.example.com, orderer.example.com, peer1.org2.example.com, peer1.org1.example.com, peer0.org1.example.com) for this project. If you removed or renamed this service in your compose file, you can run this command with the --remove-orphans flag to clean it up.Creating peer1.org3.example.com ... doneCreating peer0.org3.example.com ... doneCreating Org3cli ... done compose文件已经配置了初始网络连接，所以两个peer节点和CLI容器能够与现有的peer和排序节点连接。进入Org3-CLI容器 1docker exec -it Org3cli bash 设置两个关键环境变量ORDERER_CA 和 CHANNEL_NAME 1export ORDERER_CA&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem &amp;&amp; export CHANNEL_NAME&#x3D;mychannel 确认变量正确设置： 1echo $ORDERER_CA &amp;&amp; echo $CHANNEL_NAME 发送一个调用给排序服务请求mychannel通道的创世区块。以为上述步骤中通道已经成功更新，因此排序服务可以验证调用中附带的Org3签名。如果Org3没有成功添加到通道配置，则该请求将会被排序服务拒绝。 使用peer channel fetch命令检索区块： 1peer channel fetch 0 mychannel.block -o orderer.example.com:7050 -c $CHANNEL_NAME --tls --cafile $ORDERER_CA 将0作为参数表明希望得到的是通道账本中的第一个块（即创世块）。如果使用peer channel fetch config命令，返回的是第五个区块——Org3定义的配置更新，但新加入通道必需从创世区块0开始。 122019-10-23 01:56:32.458 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized2019-10-23 01:56:32.498 UTC [cli.common] readBlock -&gt; INFO 002 Received block: 0 利用创世块mychannel.block加入通道 1peer channel join -b mychannel.block 123root@e6a67979d990:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# peer channel join -b mychannel.block2019-10-23 01:59:59.244 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized2019-10-23 01:59:59.307 UTC [channelCmd] executeJoin -&gt; INFO 002 Successfully submitted proposal to join channel 如果需要将Org3的第二个peer也加入通道，只需要设置TLS和ADDRESS的值后再次执行上述命令： 123export CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org3.example.com&#x2F;peers&#x2F;peer1.org3.example.com&#x2F;tls&#x2F;ca.crt &amp;&amp; export CORE_PEER_ADDRESS&#x3D;peer1.org3.example.com:12051peer channel join -b mychannel.block 3.2.8 升级并调用链码升级链码版本同时更新背书策略来包含Org3。在Org3-CLI容器执行 1peer chaincode install -n mycc -v 2.0 -p github.com&#x2F;chaincode&#x2F;chaincode_example02&#x2F;go&#x2F; 1234root@e6a67979d990:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# peer chaincode install -n mycc -v 2.0 -p github.com&#x2F;chaincode&#x2F;chaincode_example02&#x2F;go&#x2F;2019-10-23 02:14:13.535 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc2019-10-23 02:14:13.535 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc2019-10-23 02:14:13.918 UTC [chaincodeCmd] install -&gt; INFO 003 Installed remotely response:&lt;status:200 payload:&quot;OK&quot; &gt; 回到原本的CLI容器，在Org1和Org2的peer上安装新版本的链码，以为上次执行通道更新调用使用Org2 管理员身份，所以当前容器代表身份仍然是peer0.org2 1peer chaincode install -n mycc -v 2.0 -p github.com&#x2F;chaincode&#x2F;chaincode_example02&#x2F;go&#x2F; 1234root@f7d186065b85:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# peer chaincode install -n mycc -v 2.0 -p github.com&#x2F;chaincode&#x2F;chaincode_example02&#x2F;go&#x2F;2019-10-23 02:18:08.241 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc2019-10-23 02:18:08.241 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc2019-10-23 02:18:08.548 UTC [chaincodeCmd] install -&gt; INFO 003 Installed remotely response:&lt;status:200 payload:&quot;OK&quot; &gt; 将容器环境切换为Org1 1234567export CORE_PEER_LOCALMSPID&#x3D;&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer0.org1.example.com&#x2F;tls&#x2F;ca.crtexport CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;mspexport CORE_PEER_ADDRESS&#x3D;peer0.org1.example.com:7051 再次执行链码安装 1peer chaincode install -n mycc -v 2.0 -p github.com&#x2F;chaincode&#x2F;chaincode_example02&#x2F;go&#x2F; 1234root@f7d186065b85:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# peer chaincode install -n mycc -v 2.0 -p github.com&#x2F;chaincode&#x2F;chaincode_example02&#x2F;go&#x2F;2019-10-23 02:19:40.763 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc2019-10-23 02:19:40.763 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc2019-10-23 02:19:40.920 UTC [chaincodeCmd] install -&gt; INFO 003 Installed remotely response:&lt;status:200 payload:&quot;OK&quot; &gt; 直至目前，链码升级已经准备完毕，这次升级并没有修改底层源代码，只是为通道mychannel中的mycc链码简单添加Org3到背书策略中。 任何满足链码实例化策略的身份都可以发布更新调用。默认情况下，该身份是通道管理员。 1peer chaincode upgrade -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n mycc -v 2.0 -c &#39;&#123;&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;90&quot;,&quot;b&quot;,&quot;210&quot;]&#125;&#39; -P &quot;OR (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;,&#39;Org3MSP.peer&#39;)&quot; -v标志指明新版本 -P可以看到已经将Org3添加到策略中去 与实例化调用一样，链码更新也需要调用init方法，如果链码中init需要参数，则更新时同样需要。 更新调用添加了一个新的区块——区块6.同时允许Org3 peer在背书阶段执行交易。123root@f7d186065b85:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# peer chaincode upgrade -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n mycc -v 2.0 -c &#39;&#123;&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;90&quot;,&quot;b&quot;,&quot;210&quot;]&#125;&#39; -P &quot;OR (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;,&#39;Org3MSP.peer&#39;)&quot;2019-10-23 02:25:18.999 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc2019-10-23 02:25:18.999 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc 回到Org3-CLI容器并查询a的值，这个过程需要耗费一些时间，因为对应peer需要构建并启动链码镜像：1peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#39; 结果12root@e6a67979d990:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#39;90 调用链码：1peer chaincode invoke -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n mycc -c &#39;&#123;&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]&#125;&#39; 12root@e6a67979d990:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# peer chaincode invoke -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n mycc -c &#39;&#123;&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]&#125;&#39;2019-10-23 02:45:08.595 UTC [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200 最后查询：1peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#39; 12root@e6a67979d990:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#39;80 3.2.9 结论通道配置更新过程确实涉及很多，但是各个步骤都有一个逻辑方法。 最终的结果是形成一个以protobuf二进制格式表示的增量交易对象，然后获取必要数量的管理员签名，以便通道配置更新交易满足通道的修改政策。主要涉及各种文件的转换与获取，如下流程图所示： 附：文件转化过程："},{"title":"couchdb","date":"2019-10-22T09:13:08.000Z","path":"2019/10/22/couchdb/","text":"Fabric默认使用LevelDB，在对链码数据建模为JSON之后，CouchDB具有针对状态数据库数据内容执行丰富和复杂查询的附加功能。 1. 关闭已经启动的fabric网络1.&#x2F;byfn.sh down 2. 生成启动first-network步骤生成网络启动所需要材料123456cryptogen generate --config&#x3D;.&#x2F;crypto-config.yamlexport FABRIC_CFG_PATH&#x3D;$PWDconfigtxgen -profile TwoOrgsOrdererGenesis -channelID byfn-sys-channel -outputBlock .&#x2F;channel-artifacts&#x2F;genesis.blockexport CHANNEL_NAME&#x3D;mychannel &amp;&amp; configtxgen -profile TwoOrgsChannel -outputCreateChannelTx .&#x2F;channel-artifacts&#x2F;channel.tx -channelID $CHANNEL_NAMEconfigtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate .&#x2F;channel-artifacts&#x2F;Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSPconfigtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate .&#x2F;channel-artifacts&#x2F;Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP 3.启动CouchDB1docker-compose -f docker-compose-cli.yaml -f docker-compose-couch.yaml up -d 123456789101112131415161718192021222324252627282930[root@localhost first-network]# docker-compose -f docker-compose-cli.yaml -f docker-compose-couch.yaml up -dCreating network &quot;net_byfn&quot; with the default driverCreating volume &quot;net_peer0.org2.example.com&quot; with default driverCreating volume &quot;net_peer1.org2.example.com&quot; with default driverCreating volume &quot;net_peer1.org1.example.com&quot; with default driverCreating volume &quot;net_peer0.org1.example.com&quot; with default driverCreating volume &quot;net_orderer.example.com&quot; with default driverCreating couchdb3 ... doneCreating orderer.example.com ... doneCreating couchdb1 ... doneCreating couchdb0 ... doneCreating couchdb2 ... doneCreating peer1.org2.example.com ... doneCreating peer0.org1.example.com ... doneCreating peer0.org2.example.com ... doneCreating peer1.org1.example.com ... doneCreating cli ... done[root@localhost first-network]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES0b819576bb29 hyperledger&#x2F;fabric-tools:latest &quot;&#x2F;bin&#x2F;bash&quot; About a minute ago Up About a minute cli924a616c7885 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; About a minute ago Up About a minute 0.0.0.0:8051-&gt;8051&#x2F;tcp peer1.org1.example.come0d8ddd1cbdc hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; About a minute ago Up About a minute 0.0.0.0:9051-&gt;9051&#x2F;tcp peer0.org2.example.com7d48491351e0 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; About a minute ago Up About a minute 0.0.0.0:7051-&gt;7051&#x2F;tcp peer0.org1.example.com14f48756e507 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; About a minute ago Up About a minute 0.0.0.0:10051-&gt;10051&#x2F;tcp peer1.org2.example.com9cce36571279 hyperledger&#x2F;fabric-couchdb &quot;tini -- &#x2F;docker-ent…&quot; About a minute ago Up About a minute 4369&#x2F;tcp, 9100&#x2F;tcp, 0.0.0.0:6984-&gt;5984&#x2F;tcp couchdb142761a41bb38 hyperledger&#x2F;fabric-couchdb &quot;tini -- &#x2F;docker-ent…&quot; About a minute ago Up About a minute 4369&#x2F;tcp, 9100&#x2F;tcp, 0.0.0.0:7984-&gt;5984&#x2F;tcp couchdb21d6db23645d0 hyperledger&#x2F;fabric-couchdb &quot;tini -- &#x2F;docker-ent…&quot; About a minute ago Up About a minute 4369&#x2F;tcp, 9100&#x2F;tcp, 0.0.0.0:5984-&gt;5984&#x2F;tcp couchdb08b2facd544eb hyperledger&#x2F;fabric-orderer:latest &quot;orderer&quot; About a minute ago Up About a minute 0.0.0.0:7050-&gt;7050&#x2F;tcp orderer.example.coma2cdad7d30ab hyperledger&#x2F;fabric-couchdb &quot;tini -- &#x2F;docker-ent…&quot; About a minute ago Up About a minute 4369&#x2F;tcp, 9100&#x2F;tcp, 0.0.0.0:8984-&gt;5984&#x2F;tcp couchdb3 注：因为不是在生产环境，所以对couchDB容器做了到主机端口的映射，使得开发环境中可以直接使用CouchDB的REST API，可通过CouchDB的WEB界面可视化数据库。生产环境需要避免端口映射，限制外部对CouchDB容器的访问。 4. 创建加入通道并更新锚节点12345docker exec -it cli bashexport CHANNEL_NAME&#x3D;mychannelpeer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f .&#x2F;channel-artifacts&#x2F;channel.tx --tls --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pempeer channel join -b mychannel.blockpeer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f .&#x2F;channel-artifacts&#x2F;Org1MSPanchors.tx --tls --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem 123456CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;users&#x2F;Admin@org2.example.com&#x2F;mspCORE_PEER_ADDRESS&#x3D;peer0.org2.example.com:9051CORE_PEER_LOCALMSPID&#x3D;&quot;Org2MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;peers&#x2F;peer0.org2.example.com&#x2F;tls&#x2F;ca.crt peer channel join -b mychannel.blockpeer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f .&#x2F;channel-artifacts&#x2F;Org2MSPanchors.tx --tls --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem 5.链码安装与实例化12peer chaincode install -n marbles -v 1.0 -p github.com&#x2F;chaincode&#x2F;marbles02&#x2F;gopeer chaincode instantiate -o orderer.example.com:7050 --tls --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -v 1.0 -c &#39;&#123;&quot;Args&quot;:[&quot;init&quot;]&#125;&#39; -P &quot;OR (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot; 6.链码调用123456peer chaincode invoke -o orderer.example.com:7050 --tls --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -c &#39;&#123;&quot;Args&quot;:[&quot;initMarble&quot;,&quot;marble1&quot;,&quot;blue&quot;,&quot;35&quot;,&quot;tom&quot;]&#125;&#39;peer chaincode invoke -o orderer.example.com:7050 --tls --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -c &#39;&#123;&quot;Args&quot;:[&quot;initMarble&quot;,&quot;marble2&quot;,&quot;red&quot;,&quot;50&quot;,&quot;tom&quot;]&#125;&#39;peer chaincode invoke -o orderer.example.com:7050 --tls --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -c &#39;&#123;&quot;Args&quot;:[&quot;initMarble&quot;,&quot;marble3&quot;,&quot;blue&quot;,&quot;70&quot;,&quot;tom&quot;]&#125;&#39;peer chaincode invoke -o orderer.example.com:7050 --tls --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -c &#39;&#123;&quot;Args&quot;:[&quot;transferMarble&quot;,&quot;marble2&quot;,&quot;jerry&quot;]&#125;&#39;peer chaincode invoke -o orderer.example.com:7050 --tls --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -c &#39;&#123;&quot;Args&quot;:[&quot;transferMarblesBasedOnColor&quot;,&quot;blue&quot;,&quot;jerry&quot;]&#125;&#39;peer chaincode invoke -o orderer.example.com:7050 --tls --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -c &#39;&#123;&quot;Args&quot;:[&quot;delete&quot;,&quot;marble1&quot;]&#125;&#39; 1234562019-10-21 06:39:47.840 UTC [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200 2019-10-21 06:39:47.892 UTC [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:2002019-10-21 06:39:47.945 UTC [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200 2019-10-21 06:39:48.002 UTC [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:2002019-10-21 06:39:48.050 UTC [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200 payload:&quot;Transferred 0 blue marbles to jerry&quot;2019-10-21 06:41:05.065 UTC [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200 因为CouchDB容器与主机做了端口映射，所以可以通过CouchDB Web接口来可视化状态数据库通过访问 http://localhost:5984/_utils,可以看到下图界面： 7.链码查询1peer chaincode query -C $CHANNEL_NAME -n marbles -c &#39;&#123;&quot;Args&quot;:[&quot;readMarble&quot;,&quot;marble2&quot;]&#125;&#39; 1&#123;&quot;color&quot;:&quot;red&quot;,&quot;docType&quot;:&quot;marble&quot;,&quot;name&quot;:&quot;marble2&quot;,&quot;owner&quot;:&quot;jerry&quot;,&quot;size&quot;:50&#125; 历史查询 1peer chaincode query -C $CHANNEL_NAME -n marbles -c &#39;&#123;&quot;Args&quot;:[&quot;getHistoryForMarble&quot;,&quot;marble1&quot;]&#125;&#39; 12[&#123;&quot;TxId&quot;:&quot;f94ca6cf8d184cb999c589eaa2c69ee8d73e76eba9c9e617f81076eec4c386d9&quot;, &quot;Value&quot;:&#123;&quot;docType&quot;:&quot;marble&quot;,&quot;name&quot;:&quot;marble1&quot;,&quot;color&quot;:&quot;blue&quot;,&quot;size&quot;:35,&quot;owner&quot;:&quot;tom&quot;&#125;, &quot;Timestamp&quot;:&quot;2019-10-21 06:39:47.834102301 +0000 UTC&quot;, &quot;IsDelete&quot;:&quot;false&quot;&#125;,&#123;&quot;TxId&quot;:&quot;0a8d6d9aaf3d2cb4088d92d6269572a8aca0134efc295c776f8be56b8bd1ef5f&quot;, &quot;Value&quot;:null, &quot;Timestamp&quot;:&quot;2019-10-21 06:41:05.059717786 +0000 UTC&quot;, &quot;IsDelete&quot;:&quot;true&quot;&#125;] 根据数据内容查询 1peer chaincode query -C $CHANNEL_NAME -n marbles -c &#39;&#123;&quot;Args&quot;:[&quot;queryMarblesByOwner&quot;,&quot;jerry&quot;]&#125;&#39; 附1：为什么要使用CouchDBCouchDB是一种NoSQL解决方案。是一个面向文件的数据库，其中文件字段存储为键值映射。 字段可以是简单的键值对，列表或映射。 除了LevelDB支持的键/复合键/键范围查询外，CouchDB还支持丰富的全数据查询功能，例如针对整个区块链数据的非键查询，因为其数据内容以JSON格式存储，并且完全可查询。 因此，CouchDB在许多使用场景中可以满足LevelDB不支持的链码、审计和报告要求。 另外，CouchDB属于CAP定理的AP类型（可用性和分区容差）。 它使用具有最终一致性的主-主复制模型。 但是，在每个peer节点下，没有数据库副本，数据库的写入是一致且持久的（不是最终一致性）。 CouchDB是第一个用于Fabric的外部可插入状态数据库，并且可能并且应该有其他外部数据库选项。 例如，IBM为其区块链启用关系数据库。 并且可能还需要CP类型（一致性和分区容差）数据库，以便在不保证应用程序级别的情况下实现数据一致性。 附2：关于数据持久性如果要在peer容器或者CouchDB容器上保持数据持久性，可以选择将主机中目录挂在到容器的相关目录中。如：在 docker-compose-cli.yaml 文件的peer容器说明中添加： 12volumes: - &#x2F;var&#x2F;hyperledger&#x2F;peer0:&#x2F;var&#x2F;hyperledger&#x2F;production 对于CouchDB容器，添加以下两行在CouchDB容器说明中： 12volumes: - &#x2F;var&#x2F;hyperledger&#x2F;couchdb0:&#x2F;opt&#x2F;couchdb&#x2F;data"},{"title":"建立你的第一个fabric网络（byfn）——step by step","date":"2019-10-22T09:05:10.000Z","path":"2019/10/22/byfn2/","text":"byfn.sh 中执行了什么命令，如何使整个fabric网络启动。这就是这篇文章所要分析的内容。 一. 工具介绍1. cryptogen生成加密材料，包括x509证书和签名密钥。这些材料允许网络实体在通信和交易时进行验证和签名。利用crypto-config.yaml文件来生成为组织和组织中的组件生成证书和密钥集。每个组织都有一个唯一的根CA，与组织中的组件相绑定。crypto-config.yaml示例文件内容如下： 1234567891011121314151617181920212223242526OrdererOrgs: - Name: Orderer Domain: example.com EnableNodeOUs: true Specs: - Hostname: orderer - Hostname: orderer2 - Hostname: orderer3 - Hostname: orderer4 - Hostname: orderer5PeerOrgs: - Name: Org1 Domain: org1.example.com EnableNodeOUs: true Template: Count: 2 Users: Count: 1 - Name: Org2 Domain: org2.example.com EnableNodeOUs: true Template: Count: 2 Users: Count: 1 “Specs”： 在配置中启动主机是显示定义，模板如下所示 Specs 是 Spec条目组。每个Spec条目包括两个内容： Hostname: (必需) 所需主机名，不需域名. CommonName: (可选) 指定CN模板或者显式覆写。默认模板如下： &quot;&#123;&#123;.Hostname&#125;&#125;.&#123;&#123;.Domain&#125;&#125;&quot; 包含 Spec.Hostname和 Org.Domain 例子如下： 12345Specs: - Hostname: foo # 代表&quot;foo.org1.example.com&quot; CommonName: foo27.org5.example.com # 覆写上面设置的主机名 - Hostname: bar - Hostname: baz “Template”： 允许定义利用模板来顺序创建1个或多个主机默认情况下，从0到Count-1以”peer%d”的形式出现 .可以修改节点数量(Count), 开始的索引(Start)和用于构建名称的模板 (Hostname). 注意: Template 和 Specs 不是互斥的。两部分可以同时定义，将会创建聚合节点。只需要留意避免名称冲突 . 例子如下： 1234Template: Count: 2 Start: 5 Hostname: &#123;&#123;.Prefix&#125;&#125;&#123;&#123;.Index&#125;&#125; # 默认 12345# ---------------------------------------------------------------------------# &quot;Users&quot;# ---------------------------------------------------------------------------# Count: 除了管理员外的用户账户# --------------------------------------------------------------------------- 在cryptogen工具运行之后，生成的证书和密钥将会保存到crypto-config文件夹。在crypto-config.yaml文件中列出5个排序节点与排序组织相绑定，因此cryptogen会为这5个排序节点生成证书，但是除非使用了raft或者kafka排序服务，否则只有一个节点用于独立排序服务实现并用来创建系统通道和mychannel。 2. configtxgenconfigtxgen工具用来生成4个配置元素： 排序节点的创世块 genesis block 通道配置交易 configuration transaction 两个锚定节点交易 anchor peer transaction 排序节点块是排序服务中的创世块，通道配置交易会在通道创建的时候广播给排序节点。而锚定节点交易即指明通道上每个组织是锚定节点。（锚定节点即负责组织与外部以及其它组织通信的节点） 与cryptogen工具类似，configtxgen也需要利用一个配置文件configtx.yaml来生成对应材料。该配置文件包含示例网络的定义。 包含三个成员： 一个排序组织(OrdererOrg)和两个节点组织(Org1 &amp; Org2)每个组织管理和维护两个节点。 文件同时指定了一个联盟——SampleConsortium， 包含上述两个节点组织。特别注意文件最后Profiles部分，出现了几个唯一的配置： TwoOrgsOrdererGenesis ：为单节点排序服务生成创世区块 SampleMultiNodeEtcdRaft ：为Raft排序服务生成创世区块。-o 选项并指定 etcdraft 时有效 SampleDevModeKafka ：为Kafka排序服务生成创世区块。-o 选项并指定 kafka 时有效 TwoOrgsChannel ：为通道生成创世块 注意，SampleConsortium是在系统级配置文件中定义的，然后由通道级配置文件引用。 通道存在于联盟的权限范围内，所有联盟都必须在整个网络范围内定义。 该文件还包含两个值得注意的附加规范。首先，为每个对等组织指定锚点对等体（peer0.org1.example.com＆peer0.org2.example.com）。其次，指向每个成员的MSP目录的位置，从而允许将每个组织的根证书存储在排序节点创始块中。 二. 命令运行1. 生成证书及密钥1cryptogen generate --config&#x3D;.&#x2F;crypto-config.yaml 因为安装二进制文件的时候已经把该执行文件路径放到环境变量中了，所以可以直接使用。 123[root@localhost first-network]# cryptogen generate --config&#x3D;.&#x2F;crypto-config.yaml org1.example.comorg2.example.com 可以看到该目录下多了一个crypto-config子目录 12345[root@localhost first-network]# ls base ccp-template.yaml connection-org1.yaml connection-org3.yaml docker-compose-cli.yaml docker-compose-etcdraft2.yaml org3-artifactsbyfn.sh channel-artifacts connection-org2.json crypto-config docker-compose-couch-org3.yaml docker-compose-kafka.yaml README.mdccp-generate.sh configtx.yaml connection-org2.yaml crypto-config.yaml docker-compose-couch.yaml docker-compose-org3.yaml scriptsccp-template.json connection-org1.json connection-org3.json docker-compose-ca.yaml docker-compose-e2e-template.yaml eyfn.sh 2. 生成配置交易2.1 创建排序创世块首先需要配置configtx.yaml文件路径，使得工具configtxgen可以找到该文件 1export FABRIC_CFG_PATH&#x3D;$PWD 执行命令 1configtxgen -profile TwoOrgsOrdererGenesis -channelID byfn-sys-channel -outputBlock .&#x2F;channel-artifacts&#x2F;genesis.block 使用配置TwoOrgsOrdererGenesis，通道ID（channelID代表系统通道的名称）设置为byfn-sys-channel，生成创世块为channel-artifacts目录下的genesis.block 12345678[root@localhost first-network]# configtxgen -profile TwoOrgsOrdererGenesis -channelID byfn-sys-channel -outputBlock .&#x2F;channel-artifacts&#x2F;genesis.block2019-10-20 15:00:32.995 CST [common.tools.configtxgen] main -&gt; INFO 001 Loading configuration2019-10-20 15:00:33.048 CST [common.tools.configtxgen.localconfig] completeInitialization -&gt; INFO 002 orderer type: solo2019-10-20 15:00:33.048 CST [common.tools.configtxgen.localconfig] Load -&gt; INFO 003 Loaded configuration: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;first-network&#x2F;configtx.yaml2019-10-20 15:00:33.106 CST [common.tools.configtxgen.localconfig] completeInitialization -&gt; INFO 004 orderer type: solo2019-10-20 15:00:33.106 CST [common.tools.configtxgen.localconfig] LoadTopLevel -&gt; INFO 005 Loaded configuration: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;first-network&#x2F;configtx.yaml2019-10-20 15:00:33.108 CST [common.tools.configtxgen] doOutputBlock -&gt; INFO 006 Generating genesis block2019-10-20 15:00:33.109 CST [common.tools.configtxgen] doOutputBlock -&gt; INFO 007 Writing genesis block 如果需要使用Raft排序服务，则使用配置SampleMultiNodeEtcdRaft，命令如下 1configtxgen -profile SampleMultiNodeEtcdRaft -channelID byfn-sys-channel -outputBlock .&#x2F;channel-artifacts&#x2F;genesis.block 如果需要使用Kafka排序服务，则使用配置SampleDevModeKafka，命令如下 1configtxgen -profile SampleDevModeKafka -channelID byfn-sys-channel -outputBlock .&#x2F;channel-artifacts&#x2F;genesis.block 2.3 创建通道配置交易设置通道名称作为环境变量同时生成配置交易 1export CHANNEL_NAME&#x3D;mychannel &amp;&amp; configtxgen -profile TwoOrgsChannel -outputCreateChannelTx .&#x2F;channel-artifacts&#x2F;channel.tx -channelID $CHANNEL_NAME 使用配置TwoOrgsChannel，生成配置交易为channel-artifacts目录下的channel.tx 1234567[root@localhost first-network]# export CHANNEL_NAME&#x3D;mychannel &amp;&amp; configtxgen -profile TwoOrgsChannel -outputCreateChannelTx .&#x2F;channel-artifacts&#x2F;channel.tx -channelID $CHANNEL_NAME2019-10-20 15:33:00.766 CST [common.tools.configtxgen] main -&gt; INFO 001 Loading configuration2019-10-20 15:33:00.820 CST [common.tools.configtxgen.localconfig] Load -&gt; INFO 002 Loaded configuration: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;first-network&#x2F;configtx.yaml2019-10-20 15:33:00.872 CST [common.tools.configtxgen.localconfig] completeInitialization -&gt; INFO 003 orderer type: solo2019-10-20 15:33:00.872 CST [common.tools.configtxgen.localconfig] LoadTopLevel -&gt; INFO 004 Loaded configuration: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;first-network&#x2F;configtx.yaml2019-10-20 15:33:00.872 CST [common.tools.configtxgen] doOutputChannelCreateTx -&gt; INFO 005 Generating new channel configtx2019-10-20 15:33:00.874 CST [common.tools.configtxgen] doOutputChannelCreateTx -&gt; INFO 006 Writing new channel tx 可以注意到在该命令中并没有明确的指令指明使用的是那种排序服务（如：Kafka 或 Raft），因为TwoOrgsChannel会使用你创建创世块时所指定的排序服务配置。 2.4 创建两个锚定节点交易创建组织1（Org1）锚节点（anchor peer） 1configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate .&#x2F;channel-artifacts&#x2F;Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP 1234567[root@localhost first-network]# configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate .&#x2F;channel-artifacts&#x2F;Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP2019-10-20 16:07:11.323 CST [common.tools.configtxgen] main -&gt; INFO 001 Loading configuration2019-10-20 16:07:11.376 CST [common.tools.configtxgen.localconfig] Load -&gt; INFO 002 Loaded configuration: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;first-network&#x2F;configtx.yaml2019-10-20 16:07:11.428 CST [common.tools.configtxgen.localconfig] completeInitialization -&gt; INFO 003 orderer type: solo2019-10-20 16:07:11.428 CST [common.tools.configtxgen.localconfig] LoadTopLevel -&gt; INFO 004 Loaded configuration: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;first-network&#x2F;configtx.yaml2019-10-20 16:07:11.428 CST [common.tools.configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 005 Generating anchor peer update2019-10-20 16:07:11.428 CST [common.tools.configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 006 Writing anchor peer update 创建同一通道上组织2（Org2）的锚节点（anchor peer） 1configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate .&#x2F;channel-artifacts&#x2F;Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP 1234567[root@localhost first-network]# configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate .&#x2F;channel-artifacts&#x2F;Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP2019-10-20 16:07:50.112 CST [common.tools.configtxgen] main -&gt; INFO 001 Loading configuration2019-10-20 16:07:50.166 CST [common.tools.configtxgen.localconfig] Load -&gt; INFO 002 Loaded configuration: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;first-network&#x2F;configtx.yaml2019-10-20 16:07:50.218 CST [common.tools.configtxgen.localconfig] completeInitialization -&gt; INFO 003 orderer type: solo2019-10-20 16:07:50.218 CST [common.tools.configtxgen.localconfig] LoadTopLevel -&gt; INFO 004 Loaded configuration: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;first-network&#x2F;configtx.yaml2019-10-20 16:07:50.218 CST [common.tools.configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 005 Generating anchor peer update2019-10-20 16:07:50.218 CST [common.tools.configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 006 Writing anchor peer update 此时查看channel-artifacts文件夹，可以看到四个所需要配置文件均生成 12[root@localhost channel-artifacts]# lschannel.tx genesis.block Org1MSPanchors.tx Org2MSPanchors.tx 3.启动网络利用docker-compose文件启动网络，使用上面步骤生成的 genesis.block 文件来启动排序服务 1docker-compose -f docker-compose-cli.yaml up -d 123456789101112131415161718192021[root@localhost first-network]# docker-compose -f docker-compose-cli.yaml up -dCreating network &quot;net_byfn&quot; with the default driverCreating volume &quot;net_peer0.org2.example.com&quot; with default driverCreating volume &quot;net_peer1.org2.example.com&quot; with default driverCreating volume &quot;net_peer1.org1.example.com&quot; with default driverCreating volume &quot;net_peer0.org1.example.com&quot; with default driverCreating volume &quot;net_orderer.example.com&quot; with default driverCreating peer0.org2.example.com ... doneCreating orderer.example.com ... doneCreating peer1.org1.example.com ... doneCreating peer1.org2.example.com ... doneCreating peer0.org1.example.com ... doneCreating cli ... done[root@localhost first-network]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3797ff79a60f hyperledger&#x2F;fabric-tools:latest &quot;&#x2F;bin&#x2F;bash&quot; 47 seconds ago Up 46 seconds cli1cd801dfe6a9 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 49 seconds ago Up 46 seconds 0.0.0.0:9051-&gt;9051&#x2F;tcp peer0.org2.example.com87bdc5b7f31e hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 49 seconds ago Up 47 seconds 0.0.0.0:10051-&gt;10051&#x2F;tcp peer1.org2.example.com35067e605249 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 49 seconds ago Up 46 seconds 0.0.0.0:8051-&gt;8051&#x2F;tcp peer1.org1.example.com349a8be2cfa9 hyperledger&#x2F;fabric-orderer:latest &quot;orderer&quot; 49 seconds ago Up 46 seconds 0.0.0.0:7050-&gt;7050&#x2F;tcp orderer.example.com1c458fb55bd8 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 49 seconds ago Up 46 seconds 0.0.0.0:7051-&gt;7051&#x2F;tcp peer0.org1.example.com 可以看到已经启动两个组织的4个节点，一个排序节点，和一个cli容器 4. 创建并加入通道上面已经创建通道配置交易，如果想要创建额外的通道，可以重复上述通道配置创建过程使用configtx.yaml中相同或者不同的配置。首先，进入cli容器 1docker exec -it cli bash 进入cli容器结果： 12[root@localhost first-network]# docker exec -it cli bashroot@3797ff79a60f:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# 因为cli容器中的默认环境变量是 peer0.org1.example.com 对应的环境变量，因此调用 peer0.org1.example.com 时可以不做变量设置，直接调用即可。但是如果需要调用其它节点，则需要在调用命令执行之前设置对应节点的环境变量。peer0.org1的环境变量如下： 123456# Environment variables for PEER0CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;mspCORE_PEER_ADDRESS&#x3D;peer0.org1.example.com:7051CORE_PEER_LOCALMSPID&#x3D;&quot;Org1MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer0.org1.example.com&#x2F;tls&#x2F;ca.crt peer0.org2的环境变量如下： 1234CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;users&#x2F;Admin@org2.example.com&#x2F;msp CORE_PEER_ADDRESS&#x3D;peer0.org2.example.com:9051 CORE_PEER_LOCALMSPID&#x3D;&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;peers&#x2F;peer0.org2.example.com&#x2F;tls&#x2F;ca.crt 4.1 创建通道将生成的通道配置交易channel.tx传给orderer，作为通道创建需求的一部分，注意通道名称不能出现大写字母。 12export CHANNEL_NAME&#x3D;mychannelpeer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f .&#x2F;channel-artifacts&#x2F;channel.tx --tls --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem 命令中的cafile是orderer根证书的本地路径，可以用来验证TLS握手。命令会返回一个创世区块 -&lt;CHANNEL_NAME.block&gt;，包含channel.tx中指定的配置信息。本次示例返回mychannel.block，在加入通道时需要使用到。 123452019-10-20 09:21:41.951 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized2019-10-20 09:21:41.998 UTC [cli.common] readBlock -&gt; INFO 002 Received block: 0root@3797ff79a60f:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# lschannel-artifacts crypto mychannel.block scripts 4.2 加入通道将peer0.org1.example.com加入通道 1peer channel join -b mychannel.block 122019-10-20 09:25:43.238 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized2019-10-20 09:25:43.279 UTC [channelCmd] executeJoin -&gt; INFO 002 Successfully submitted proposal to join channel 将peer0.org2.example.com加入通道，需要先设置环境变量为peer0.org2.example.com对应的环境变量再执行命令 12345CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;users&#x2F;Admin@org2.example.com&#x2F;mspCORE_PEER_ADDRESS&#x3D;peer0.org2.example.com:9051CORE_PEER_LOCALMSPID&#x3D;&quot;Org2MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;peers&#x2F;peer0.org2.example.com&#x2F;tls&#x2F;ca.crt peer channel join -b mychannel.block 122019-10-20 09:30:00.602 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized2019-10-20 09:30:00.639 UTC [channelCmd] executeJoin -&gt; INFO 002 Successfully submitted proposal to join channel 4.3 更新锚节点更新锚节点会传播到通道的定义。从本质上来讲，是在通道的创世区块上添加配置信息。但这不是修改创世区块，而是添加锚节点的定义到链中。 更新通道定义将Org1的锚节点定义为 peer0.org1.example.com。将生成的锚节点交易Org1MSPanchors.tx传给orderer 1peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f .&#x2F;channel-artifacts&#x2F;Org1MSPanchors.tx --tls --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem 122019-10-20 11:28:10.858 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized2019-10-20 11:28:10.877 UTC [channelCmd] update -&gt; INFO 002 Successfully submitted channel update 更新通道定义将Org2的锚节点定义为 peer0.org2.example.com： 12345CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;users&#x2F;Admin@org2.example.com&#x2F;mspCORE_PEER_ADDRESS&#x3D;peer0.org2.example.com:9051 CORE_PEER_LOCALMSPID&#x3D;&quot;Org2MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;peers&#x2F;peer0.org2.example.com&#x2F;tls&#x2F;ca.crtpeer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f .&#x2F;channel-artifacts&#x2F;Org2MSPanchors.tx --tls --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem 122019-10-20 11:29:46.293 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized2019-10-20 11:29:46.320 UTC [channelCmd] update -&gt; INFO 002 Successfully submitted channel update 4.4 安装链码本示例中，使用简单已经存在的链码。应用通过链码与区块链账本进行交互。因此在每个需要执行和背书的节点上都需要安装链码，然后在对应通道中将链码实例化。 首先安装链码，该命令将链码放置到对应节点的文件系统中。每个链码名称和版本只能对应一个链码源代码。 1peer chaincode install -n mycc -v 1.0 -p github.com&#x2F;chaincode&#x2F;chaincode_example02&#x2F;go&#x2F; -n 链码名称 -v 链码版本 -p 链码路径 -l 链码语言（默认golang）1232019-10-20 11:52:41.045 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc2019-10-20 11:52:41.045 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc2019-10-20 11:52:41.613 UTC [chaincodeCmd] install -&gt; INFO 003 Installed remotely response:&lt;status:200 payload:&quot;OK&quot; &gt; Node.js版本1peer chaincode install -n mycc -v 1.0 -l node -p &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;chaincode&#x2F;chaincode_example02&#x2F;node&#x2F; Java版本1peer chaincode install -n mycc -v 1.0 -l java -p &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;chaincode&#x2F;chaincode_example02&#x2F;java&#x2F; 将链码安装在Org2的peer0上,修改环境变量1234CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;users&#x2F;Admin@org2.example.com&#x2F;mspCORE_PEER_ADDRESS&#x3D;peer0.org2.example.com:9051CORE_PEER_LOCALMSPID&#x3D;&quot;Org2MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;peers&#x2F;peer0.org2.example.com&#x2F;tls&#x2F;ca.crt 安装链码：1peer chaincode install -n mycc -v 1.0 -p github.com&#x2F;chaincode&#x2F;chaincode_example02&#x2F;go&#x2F; 1232019-10-20 11:57:55.352 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc2019-10-20 11:57:55.352 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc2019-10-20 11:57:55.585 UTC [chaincodeCmd] install -&gt; INFO 003 Installed remotely response:&lt;status:200 payload:&quot;OK&quot; &gt; 4.5 实例化链码实例化链码即初始化通道上的链码并为链码设置背书策略，然后为目标节点启动链码容器。其中-P参数对应的是指定的背书策略，指定对应交易验证所需要的条件。 在示例中使用 -P &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;，表示需要来自Org1和Org2的背书交易才能验证通过，缺一不可。如果将其中的AND改成OR，则只需要两者之一即可。 实例化链码： 1peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 1.0 -c &#39;&#123;&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]&#125;&#39; -P &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot; 122019-10-20 12:10:25.198 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc2019-10-20 12:10:25.198 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc 如果需要其它节点参加到账本的交互中来的话，只需要将同样名称、版本和语言的链码源码安装到对应的节点上。当节点想要与特定链码交互的时候，对应的链码容器将会被启动。 实例化完成后可以看到启动了一个链码容器： 123456789[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESfba2e8af5e59 dev-peer0.org2.example.com-mycc-1.0-15b571b3ce849066b7ec74497da3b27e54e0df1345daff3951b94245ce09c42b &quot;chaincode -peer.add…&quot; 2 minutes ago Up 2 minutes dev-peer0.org2.example.com-mycc-1.03797ff79a60f hyperledger&#x2F;fabric-tools:latest &quot;&#x2F;bin&#x2F;bash&quot; 4 hours ago Up 4 hours cli1cd801dfe6a9 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 4 hours ago Up 4 hours 0.0.0.0:9051-&gt;9051&#x2F;tcp peer0.org2.example.com87bdc5b7f31e hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 4 hours ago Up 4 hours 0.0.0.0:10051-&gt;10051&#x2F;tcp peer1.org2.example.com35067e605249 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 4 hours ago Up 4 hours 0.0.0.0:8051-&gt;8051&#x2F;tcp peer1.org1.example.com349a8be2cfa9 hyperledger&#x2F;fabric-orderer:latest &quot;orderer&quot; 4 hours ago Up 4 hours 0.0.0.0:7050-&gt;7050&#x2F;tcp orderer.example.com1c458fb55bd8 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 4 hours ago Up 4 hours 0.0.0.0:7051-&gt;7051&#x2F;tcp peer0.org1.example.com Node.js版本 1peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -l node -v 1.0 -c &#39;&#123;&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]&#125;&#39; -P &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot; Java版本 1peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -l java -v 1.0 -c &#39;&#123;&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]&#125;&#39; -P &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot; 4.6 链码查询1peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#39; 12root@3797ff79a60f:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#39;100 4.7 链码调用1peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer0.org1.example.com&#x2F;tls&#x2F;ca.crt --peerAddresses peer0.org2.example.com:9051 --tlsRootCertFiles &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;peers&#x2F;peer0.org2.example.com&#x2F;tls&#x2F;ca.crt -c &#39;&#123;&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]&#125;&#39; 12019-10-20 12:29:16.689 UTC [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200 再次查询 1peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#39; 12root@3797ff79a60f:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#39;90 此时可以看到存在两个链码镜像，因为链码调用的时候peer0.org1需要与账本交互，此前已经安装了对应链码，因此会自动启动对应的链码容器。 12345678910[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3a32eea0e068 dev-peer0.org1.example.com-mycc-1.0-384f11f484b9302df90b453200cfb25174305fce8f53f4e94d45ee3b6cab0ce9 &quot;chaincode -peer.add…&quot; 2 seconds ago Up 2 seconds dev-peer0.org1.example.com-mycc-1.0fba2e8af5e59 dev-peer0.org2.example.com-mycc-1.0-15b571b3ce849066b7ec74497da3b27e54e0df1345daff3951b94245ce09c42b &quot;chaincode -peer.add…&quot; 15 minutes ago Up 15 minutes dev-peer0.org2.example.com-mycc-1.03797ff79a60f hyperledger&#x2F;fabric-tools:latest &quot;&#x2F;bin&#x2F;bash&quot; 4 hours ago Up 4 hours cli1cd801dfe6a9 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 4 hours ago Up 4 hours 0.0.0.0:9051-&gt;9051&#x2F;tcp peer0.org2.example.com87bdc5b7f31e hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 4 hours ago Up 4 hours 0.0.0.0:10051-&gt;10051&#x2F;tcp peer1.org2.example.com35067e605249 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 4 hours ago Up 4 hours 0.0.0.0:8051-&gt;8051&#x2F;tcp peer1.org1.example.com349a8be2cfa9 hyperledger&#x2F;fabric-orderer:latest &quot;orderer&quot; 4 hours ago Up 4 hours 0.0.0.0:7050-&gt;7050&#x2F;tcp orderer.example.com1c458fb55bd8 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 4 hours ago Up 4 hours 0.0.0.0:7051-&gt;7051&#x2F;tcp peer0.org1.example.com 4.8 在第三个节点上安装链码本次将链码安装在Org2的peer1上。同样，首先修改环境变量： 1234CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;users&#x2F;Admin@org2.example.com&#x2F;mspCORE_PEER_ADDRESS&#x3D;peer1.org2.example.com:10051CORE_PEER_LOCALMSPID&#x3D;&quot;Org2MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;peers&#x2F;peer1.org2.example.com&#x2F;tls&#x2F;ca.crt 安装链码： 1peer chaincode install -n mycc -v 1.0 -p github.com&#x2F;chaincode&#x2F;chaincode_example02&#x2F;go&#x2F; 1232019-10-20 12:40:01.588 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc2019-10-20 12:40:01.588 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc2019-10-20 12:40:01.809 UTC [chaincodeCmd] install -&gt; INFO 003 Installed remotely response:&lt;status:200 payload:&quot;OK&quot; &gt; 因为在上述链码中，变量a被初始化为100，接着在调用的时候被转走10，因此对a的查询最后应该返回90。为了确认我们可以在Org2的peer1上进行查询，首先应该先加入通道 12345CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;users&#x2F;Admin@org2.example.com&#x2F;mspCORE_PEER_ADDRESS&#x3D;peer1.org2.example.com:10051 CORE_PEER_LOCALMSPID&#x3D;&quot;Org2MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;peers&#x2F;peer1.org2.example.com&#x2F;tls&#x2F;ca.crt peer channel join -b mychannel.block 122019-10-20 12:45:00.417 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized2019-10-20 12:45:00.439 UTC [channelCmd] executeJoin -&gt; INFO 002 Successfully submitted proposal to join channel 加入通道后即可进行查询： 1peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#39; 12root@3797ff79a60f:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer# peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&#39;90 返回结果无误，而且在查询过程中，需要等待一段时间才会有响应，是因为在Org2的peer1节点上也不存在着已经启动的链码容器，因为这是该节点第一次与账本交互，因此会启动对应的链码容器，花费一定时间。 1234567891011[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb25b1a4c1ea3 dev-peer1.org2.example.com-mycc-1.0-26c2ef32838554aac4f7ad6f100aca865e87959c9a126e86d764c8d01f8346ab &quot;chaincode -peer.add…&quot; 2 minutes ago Up 2 minutes dev-peer1.org2.example.com-mycc-1.03a32eea0e068 dev-peer0.org1.example.com-mycc-1.0-384f11f484b9302df90b453200cfb25174305fce8f53f4e94d45ee3b6cab0ce9 &quot;chaincode -peer.add…&quot; 23 minutes ago Up 23 minutes dev-peer0.org1.example.com-mycc-1.0fba2e8af5e59 dev-peer0.org2.example.com-mycc-1.0-15b571b3ce849066b7ec74497da3b27e54e0df1345daff3951b94245ce09c42b &quot;chaincode -peer.add…&quot; 38 minutes ago Up 38 minutes dev-peer0.org2.example.com-mycc-1.03797ff79a60f hyperledger&#x2F;fabric-tools:latest &quot;&#x2F;bin&#x2F;bash&quot; 4 hours ago Up 4 hours cli1cd801dfe6a9 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 4 hours ago Up 4 hours 0.0.0.0:9051-&gt;9051&#x2F;tcp peer0.org2.example.com87bdc5b7f31e hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 4 hours ago Up 4 hours 0.0.0.0:10051-&gt;10051&#x2F;tcp peer1.org2.example.com35067e605249 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 4 hours ago Up 4 hours 0.0.0.0:8051-&gt;8051&#x2F;tcp peer1.org1.example.com349a8be2cfa9 hyperledger&#x2F;fabric-orderer:latest &quot;orderer&quot; 4 hours ago Up 4 hours 0.0.0.0:7050-&gt;7050&#x2F;tcp orderer.example.com1c458fb55bd8 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 4 hours ago Up 4 hours 0.0.0.0:7051-&gt;7051&#x2F;tcp peer0.org1.example.com 注： 如果需要对账本成功执行读/写操作，必需要在对应节点上安装链码。链码容器会在初始化或者传统读写交易的触发下才会开始启动。 通道中的所有节点都会维护一个精确的账本副本，将不可篡改和顺序的区块数据组成区块链，来维护当前状态。这些节点也包括了没有安装链码但已经加入该通道的节点。 如果要访问链码，只需要在对应节点上安装上链码源码即可，因为链码已经被实例化过了。 4.9 查看交易1docker logs -f cli 4.10 查看链码日志123docker logs dev-peer0.org2.example.com-mycc-1.0docker logs dev-peer0.org1.example.com-mycc-1.0docker logs dev-peer1.org2.example.com-mycc-1.0 123456789101112131415161718192021222324252627[root@localhost ~]# docker logs dev-peer0.org2.example.com-mycc-1.0ex02 InitAval &#x3D; 100, Bval &#x3D; 200ex02 InvokeQuery Response:&#123;&quot;Name&quot;:&quot;a&quot;,&quot;Amount&quot;:&quot;100&quot;&#125;ex02 InvokeAval &#x3D; 90, Bval &#x3D; 210[root@localhost ~]# docker logs dev-peer0.org1.example.com-mycc-1.0ex02 InvokeQuery Response:&#123;&quot;Name&quot;:&quot;a&quot;,&quot;Amount&quot;:&quot;100&quot;&#125;ex02 InvokeAval &#x3D; 90, Bval &#x3D; 210ex02 InvokeQuery Response:&#123;&quot;Name&quot;:&quot;a&quot;,&quot;Amount&quot;:&quot;90&quot;&#125;ex02 InvokeQuery Response:&#123;&quot;Name&quot;:&quot;a&quot;,&quot;Amount&quot;:&quot;90&quot;&#125;ex02 InvokeQuery Response:&#123;&quot;Name&quot;:&quot;a&quot;,&quot;Amount&quot;:&quot;90&quot;&#125;ex02 InvokeQuery Response:&#123;&quot;Name&quot;:&quot;a&quot;,&quot;Amount&quot;:&quot;90&quot;&#125;[root@localhost ~]# docker logs dev-peer1.org2.example.com-mycc-1.0ex02 InvokeQuery Response:&#123;&quot;Name&quot;:&quot;a&quot;,&quot;Amount&quot;:&quot;90&quot;&#125;ex02 InvokeQuery Response:&#123;&quot;Name&quot;:&quot;a&quot;,&quot;Amount&quot;:&quot;90&quot;&#125;"},{"title":"建立你的第一个fabric网络（byfn）——脚本版","date":"2019-10-22T09:05:04.000Z","path":"2019/10/22/byfn1/","text":"在利用脚本建立第一个网络之前，需要先下载fabric-sample。如果安装环境是时候使用bootstrap.sh默认安装，则fabric-sample是已经下载的了。否则进入目录 /opt/opt/gopath/src/github.com/hyperledger/ 下克隆fabric-sample项目。以下教程默认已经安装fabric-sample 1. 进入first-network目录12cd &#x2F;opt&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-sample&#x2F;first-networkls 可以看到目录下存在名为byfn.sh的脚本文件，下面将利用该脚本文件启动fabric网络 12345[root@localhost first-network]# lsbase ccp-template.yaml connection-org1.yaml connection-org3.yaml docker-compose-couch-org3.yaml docker-compose-kafka.yaml README.mdbyfn.sh channel-artifacts connection-org2.json crypto-config.yaml docker-compose-couch.yaml docker-compose-org3.yaml scriptsccp-generate.sh configtx.yaml connection-org2.yaml docker-compose-ca.yaml docker-compose-e2e-template.yaml eyfn.shccp-template.json connection-org1.json connection-org3.json docker-compose-cli.yaml docker-compose-etcdraft2.yaml org3-artifacts 2. 创建实体证书和配置交易1.&#x2F;byfn.sh generate 执行结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172[root@localhost first-network]# .&#x2F;byfn.sh generateGenerating certs and genesis block for channel &#39;mychannel&#39; with CLI timeout of &#39;10&#39; seconds and CLI delay of &#39;3&#39; secondsContinue? [Y&#x2F;n] yproceeding ...&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;release&#x2F;linux-amd64&#x2F;bin&#x2F;cryptogen############################################################### Generate certificates using cryptogen tool ###################################################################+ cryptogen generate --config&#x3D;.&#x2F;crypto-config.yamlorg1.example.comorg2.example.com+ res&#x3D;0+ set +xGenerate CCP files for Org1 and Org2&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;release&#x2F;linux-amd64&#x2F;bin&#x2F;configtxgen################################################################### Generating Orderer Genesis block ########################################################################CONSENSUS_TYPE&#x3D;solo+ &#39;[&#39; solo &#x3D;&#x3D; solo &#39;]&#39;+ configtxgen -profile TwoOrgsOrdererGenesis -channelID byfn-sys-channel -outputBlock .&#x2F;channel-artifacts&#x2F;genesis.block2019-10-19 11:01:15.267 CST [common.tools.configtxgen] main -&gt; INFO 001 Loading configuration2019-10-19 11:01:15.324 CST [common.tools.configtxgen.localconfig] completeInitialization -&gt; INFO 002 orderer type: solo2019-10-19 11:01:15.324 CST [common.tools.configtxgen.localconfig] Load -&gt; INFO 003 Loaded configuration: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;first-network&#x2F;configtx.yaml2019-10-19 11:01:15.376 CST [common.tools.configtxgen.localconfig] completeInitialization -&gt; INFO 004 orderer type: solo2019-10-19 11:01:15.376 CST [common.tools.configtxgen.localconfig] LoadTopLevel -&gt; INFO 005 Loaded configuration: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;first-network&#x2F;configtx.yaml2019-10-19 11:01:15.378 CST [common.tools.configtxgen] doOutputBlock -&gt; INFO 006 Generating genesis block2019-10-19 11:01:15.378 CST [common.tools.configtxgen] doOutputBlock -&gt; INFO 007 Writing genesis block+ res&#x3D;0+ set +x#################################################################### Generating channel configuration transaction &#39;channel.tx&#39; ####################################################################+ configtxgen -profile TwoOrgsChannel -outputCreateChannelTx .&#x2F;channel-artifacts&#x2F;channel.tx -channelID mychannel2019-10-19 11:01:15.401 CST [common.tools.configtxgen] main -&gt; INFO 001 Loading configuration2019-10-19 11:01:15.454 CST [common.tools.configtxgen.localconfig] Load -&gt; INFO 002 Loaded configuration: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;first-network&#x2F;configtx.yaml2019-10-19 11:01:15.507 CST [common.tools.configtxgen.localconfig] completeInitialization -&gt; INFO 003 orderer type: solo2019-10-19 11:01:15.507 CST [common.tools.configtxgen.localconfig] LoadTopLevel -&gt; INFO 004 Loaded configuration: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;first-network&#x2F;configtx.yaml2019-10-19 11:01:15.507 CST [common.tools.configtxgen] doOutputChannelCreateTx -&gt; INFO 005 Generating new channel configtx2019-10-19 11:01:15.509 CST [common.tools.configtxgen] doOutputChannelCreateTx -&gt; INFO 006 Writing new channel tx+ res&#x3D;0+ set +x######################################################################## Generating anchor peer update for Org1MSP ###########################################################################+ configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate .&#x2F;channel-artifacts&#x2F;Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP2019-10-19 11:01:15.554 CST [common.tools.configtxgen] main -&gt; INFO 001 Loading configuration2019-10-19 11:01:15.606 CST [common.tools.configtxgen.localconfig] Load -&gt; INFO 002 Loaded configuration: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;first-network&#x2F;configtx.yaml2019-10-19 11:01:15.658 CST [common.tools.configtxgen.localconfig] completeInitialization -&gt; INFO 003 orderer type: solo2019-10-19 11:01:15.658 CST [common.tools.configtxgen.localconfig] LoadTopLevel -&gt; INFO 004 Loaded configuration: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;first-network&#x2F;configtx.yaml2019-10-19 11:01:15.658 CST [common.tools.configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 005 Generating anchor peer update2019-10-19 11:01:15.658 CST [common.tools.configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 006 Writing anchor peer update+ res&#x3D;0+ set +x######################################################################## Generating anchor peer update for Org2MSP ###########################################################################+ configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate .&#x2F;channel-artifacts&#x2F;Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP2019-10-19 11:01:15.678 CST [common.tools.configtxgen] main -&gt; INFO 001 Loading configuration2019-10-19 11:01:15.731 CST [common.tools.configtxgen.localconfig] Load -&gt; INFO 002 Loaded configuration: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;first-network&#x2F;configtx.yaml2019-10-19 11:01:15.783 CST [common.tools.configtxgen.localconfig] completeInitialization -&gt; INFO 003 orderer type: solo2019-10-19 11:01:15.783 CST [common.tools.configtxgen.localconfig] LoadTopLevel -&gt; INFO 004 Loaded configuration: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples&#x2F;first-network&#x2F;configtx.yaml2019-10-19 11:01:15.783 CST [common.tools.configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 005 Generating anchor peer update2019-10-19 11:01:15.783 CST [common.tools.configtxgen] doOutputAnchorPeersUpdate -&gt; INFO 006 Writing anchor peer update+ res&#x3D;0+ set +x 该步骤执行以下命令 为网络实体生成证书和密钥 生成启动排序服务的创世区块 生成配置通道所需要的配置交易集合 3. 启动网络1.&#x2F;byfn.sh up 该命令默认编译并启动golang链码镜像如果使用node.js或者java链码，可以使用以下命令： 12.&#x2F;byfn.sh -l node &#x2F;&#x2F;node.js链码启动命令.&#x2F;byfn.sh -l java &#x2F;&#x2F;java链码启动命令 执行结果： 123456789101112131415161718192021222324252627282930Creating network &quot;net_byfn&quot; with the default driverCreating volume &quot;net_peer0.org2.example.com&quot; with default driverCreating volume &quot;net_peer1.org2.example.com&quot; with default driverCreating volume &quot;net_peer1.org1.example.com&quot; with default driverCreating volume &quot;net_peer0.org1.example.com&quot; with default driverCreating volume &quot;net_orderer.example.com&quot; with default driverCreating peer0.org2.example.com ... doneCreating orderer.example.com ... doneCreating peer1.org2.example.com ... doneCreating peer1.org1.example.com ... doneCreating peer0.org1.example.com ... doneCreating cli ... doneCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7bccf9fbbdfc hyperledger&#x2F;fabric-tools:latest &quot;&#x2F;bin&#x2F;bash&quot; 1 second ago Up Less than a second cli5965f6980409 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 3 seconds ago Up Less than a second 0.0.0.0:7051-&gt;7051&#x2F;tcp peer0.org1.example.comc0b4948a2120 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 3 seconds ago Up Less than a second 0.0.0.0:8051-&gt;8051&#x2F;tcp peer1.org1.example.com36d1b4ee086a hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 3 seconds ago Up Less than a second 0.0.0.0:10051-&gt;10051&#x2F;tcp peer1.org2.example.com990eb2e086df hyperledger&#x2F;fabric-orderer:latest &quot;orderer&quot; 3 seconds ago Up Less than a second 0.0.0.0:7050-&gt;7050&#x2F;tcp orderer.example.com13dbf13c7a50 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 3 seconds ago Up 1 second 0.0.0.0:9051-&gt;9051&#x2F;tcp peer0.org2.example.com ____ _____ _ ____ _____ &#x2F; ___| |_ _| &#x2F; \\ | _ \\ |_ _|\\___ \\ | | &#x2F; _ \\ | |_) | | | ___) | | | &#x2F; ___ \\ | _ &lt; | | |____&#x2F; |_| &#x2F;_&#x2F; \\_\\ |_| \\_\\ |_| Build your first network (BYFN) end-to-end testChannel name : mychannelCreating channel... 12345678&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; All GOOD, BYFN execution completed &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; _____ _ _ ____ | ____| | \\ | | | _ \\ | _| | \\| | | | | | | |___ | |\\ | | |_| | |_____| |_| \\_| |____&#x2F; 至此，我们的第一个fabric网络启动成功，查看正在运行的docker容器如下： 1234567891011[root@localhost first-network]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6fcfd0974e3b dev-peer1.org2.example.com-mycc-1.0-26c2ef32838554aac4f7ad6f100aca865e87959c9a126e86d764c8d01f8346ab &quot;chaincode -peer.add…&quot; 4 minutes ago Up 4 minutes dev-peer1.org2.example.com-mycc-1.00f84dd3b767d dev-peer0.org1.example.com-mycc-1.0-384f11f484b9302df90b453200cfb25174305fce8f53f4e94d45ee3b6cab0ce9 &quot;chaincode -peer.add…&quot; 4 minutes ago Up 4 minutes dev-peer0.org1.example.com-mycc-1.0d93f067ed43d dev-peer0.org2.example.com-mycc-1.0-15b571b3ce849066b7ec74497da3b27e54e0df1345daff3951b94245ce09c42b &quot;chaincode -peer.add…&quot; 4 minutes ago Up 4 minutes dev-peer0.org2.example.com-mycc-1.07bccf9fbbdfc hyperledger&#x2F;fabric-tools:latest &quot;&#x2F;bin&#x2F;bash&quot; 5 minutes ago Up 5 minutes cli5965f6980409 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 5 minutes ago Up 5 minutes 0.0.0.0:7051-&gt;7051&#x2F;tcp peer0.org1.example.comc0b4948a2120 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 5 minutes ago Up 5 minutes 0.0.0.0:8051-&gt;8051&#x2F;tcp peer1.org1.example.com36d1b4ee086a hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 5 minutes ago Up 5 minutes 0.0.0.0:10051-&gt;10051&#x2F;tcp peer1.org2.example.com990eb2e086df hyperledger&#x2F;fabric-orderer:latest &quot;orderer&quot; 5 minutes ago Up 5 minutes 0.0.0.0:7050-&gt;7050&#x2F;tcp orderer.example.com13dbf13c7a50 hyperledger&#x2F;fabric-peer:latest &quot;peer node start&quot; 5 minutes ago Up 5 minutes 0.0.0.0:9051-&gt;9051&#x2F;tcp peer0.org2.example.com 可以看到已经启动4个peer节点和一个orderer排序节点。同时在三个peer节点上实例化了mycc链码。 4. 关闭网络1.&#x2F;byfn.sh down 该命令会停止上述已经运行的容器同时删除上述步骤所生成的所有材料，包括证书，密钥和配置交易。同时将生成的链码镜像同时删除。"},{"title":"fabric-bootstrap到底做了什么？","date":"2019-10-21T08:30:50.000Z","path":"2019/10/21/fabric-bootstrap/","text":"我们在fabric1.4的下载安装的时候，下载了bootstrap.sh,并利用它来拉取镜像和下载并二进制可执行文件。但是在这个过程bootstrap.sh做了啥？这就是下面要分析的内容 一. 命令分析执行bootstrap.sh 时使用了以下命令 1curl -sSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hyperledger&#x2F;fabric&#x2F;master&#x2F;scripts&#x2F;bootstrap.sh | bash -s -- 1.4.3 1.4.3 0.4.15 其中 -sSL 代表含义如下： 123-s, --silent Silent mode-S, --show-error Show error even when -s is used-L, --location Follow redirects s :沉默模式 ，不输出请求过程的任何信息S ：当使用沉默模式的时候，如果出现错误事件需要显示出来L ：短连接进行重定向，原本命令为 1curl -sSL http:&#x2F;&#x2F;bit.ly&#x2F;2ysbOFE | bash -s -- 1.4.3 1.4.3 0.4.15 其中链接为短链接，短链接会重新定向到真正的目标地址。但是使用的时候短链接失效，所以使用了官方教程中提供的长链接。 命令中的竖线 “|” 表示管道，即上个命令输出的内容，交给下一个命令执行。这里表示将下载的bootstrap.sh下载后交给bash执行。 后面跟着的 1.4.3 1.4.3 0.4.15分别表示fabric 、fabric-ca 、第三方镜像（couchdb, kafka 和 zookeeper）版本 后面还可以跟着可选命令 -h -d -s -b 具体含义下面分析： 123456789101112printHelp() &#123; echo &quot;Usage: bootstrap.sh [version [ca_version [thirdparty_version]]] [options]&quot; echo echo &quot;options:&quot; echo &quot;-h : this help&quot; echo &quot;-d : bypass docker image download&quot; echo &quot;-s : bypass fabric-samples repo clone&quot; echo &quot;-b : bypass download of platform-specific binaries&quot; echo echo &quot;e.g. bootstrap.sh 1.4.3 -s&quot; echo &quot;would download docker images and binaries for version 1.4.3&quot;&#125; 从bootstrap.sh中提取出来的帮助函数可以看出 -h : 提示 -d ：跳过docker镜像下载 -s ：跳过fabric-sample的克隆 -b ：跳过指定平台二进制文件下载 具体执行过程如下，整个脚本主要做3件事 克隆fabric-sample 下载特定平台的fabric二进制可执行文件和配置文件 下载指定版本的fabric的docker镜像12345678910111213141516171819202122232425262728293031323334353637DOCKER&#x3D;trueSAMPLES&#x3D;trueBINARIES&#x3D;true# then parse optswhile getopts &quot;h?dsb&quot; opt; do case &quot;$opt&quot; in h|\\?) printHelp exit 0 ;; d) DOCKER&#x3D;false ;; s) SAMPLES&#x3D;false ;; b) BINARIES&#x3D;false ;; esacdoneif [ &quot;$SAMPLES&quot; &#x3D;&#x3D; &quot;true&quot; ]; then echo echo &quot;Installing hyperledger&#x2F;fabric-samples repo&quot; echo samplesInstallfiif [ &quot;$BINARIES&quot; &#x3D;&#x3D; &quot;true&quot; ]; then echo echo &quot;Installing Hyperledger Fabric binaries&quot; echo binariesInstallfiif [ &quot;$DOCKER&quot; &#x3D;&#x3D; &quot;true&quot; ]; then echo echo &quot;Installing Hyperledger Fabric docker images&quot; echo dockerInstallfi 其中 samplesInstall、 binariesInstall、 dockerInstall分别代表克隆fabric-sample、下载二进制可执行文件、下载docker镜像。 二. 功能具体如下分析：2.1 samplesInstall1234567891011121314151617samplesInstall() &#123; # clone (if needed) hyperledger&#x2F;fabric-samples and checkout corresponding # version to the binaries and docker images to be downloaded if [ -d first-network ]; then # if we are in the fabric-samples repo, checkout corresponding version echo &quot;&#x3D;&#x3D;&#x3D;&gt; Checking out v$&#123;VERSION&#125; of hyperledger&#x2F;fabric-samples&quot; git checkout v$&#123;VERSION&#125; elif [ -d fabric-samples ]; then # if fabric-samples repo already cloned and in current directory, # cd fabric-samples and checkout corresponding version echo &quot;&#x3D;&#x3D;&#x3D;&gt; Checking out v$&#123;VERSION&#125; of hyperledger&#x2F;fabric-samples&quot; cd fabric-samples &amp;&amp; git checkout v$&#123;VERSION&#125; else echo &quot;&#x3D;&#x3D;&#x3D;&gt; Cloning hyperledger&#x2F;fabric-samples repo and checkout v$&#123;VERSION&#125;&quot; git clone -b master https:&#x2F;&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples.git &amp;&amp; cd fabric-samples &amp;&amp; git checkout v$&#123;VERSION&#125; fi&#125; git clone -b master https://github.com/hyperledger/fabric-samples.git &amp;&amp; cd fabric-samples &amp;&amp; git checkout v$&#123;VERSION&#125; 该命令即表示从github仓库克隆fabric-sample并进入该目录后检出指定版本。 2.2 binariesInstall1234567891011121314151617binariesInstall() &#123; echo &quot;&#x3D;&#x3D;&#x3D;&gt; Downloading version $&#123;FABRIC_TAG&#125; platform specific fabric binaries&quot; binaryDownload &quot;$&#123;BINARY_FILE&#125;&quot; &quot;https:&#x2F;&#x2F;nexus.hyperledger.org&#x2F;content&#x2F;repositories&#x2F;releases&#x2F;org&#x2F;hyperledger&#x2F;fabric&#x2F;hyperledger-fabric&#x2F;$&#123;ARCH&#125;-$&#123;VERSION&#125;&#x2F;$&#123;BINARY_FILE&#125;&quot; if [ $? -eq 22 ]; then echo echo &quot;------&gt; $&#123;FABRIC_TAG&#125; platform specific fabric binary is not available to download &lt;----&quot; echo fi echo &quot;&#x3D;&#x3D;&#x3D;&gt; Downloading version $&#123;CA_TAG&#125; platform specific fabric-ca-client binary&quot; binaryDownload &quot;$&#123;CA_BINARY_FILE&#125;&quot; &quot;https:&#x2F;&#x2F;nexus.hyperledger.org&#x2F;content&#x2F;repositories&#x2F;releases&#x2F;org&#x2F;hyperledger&#x2F;fabric-ca&#x2F;hyperledger-fabric-ca&#x2F;$&#123;ARCH&#125;-$&#123;CA_VERSION&#125;&#x2F;$&#123;CA_BINARY_FILE&#125;&quot; if [ $? -eq 22 ]; then echo echo &quot;------&gt; $&#123;CA_TAG&#125; fabric-ca-client binary is not available to download (Available from 1.1.0-rc1) &lt;----&quot; echo fi&#125; 该函数调用binaryDownload到指定地址下载二进制文件压缩包。 2.2.1 binaryDownload12345678910111213141516171819202122# This will attempt to download the .tar.gz all at once, but will trigger the# binaryIncrementalDownload() function upon a failure, allowing for resume# if there are network failures.binaryDownload() &#123; local BINARY_FILE&#x3D;$1 local URL&#x3D;$2 echo &quot;&#x3D;&#x3D;&#x3D;&gt; Downloading: &quot; &quot;$&#123;URL&#125;&quot; # Check if a previous failure occurred and the file was partially downloaded if [ -e &quot;$&#123;BINARY_FILE&#125;&quot; ]; then echo &quot;&#x3D;&#x3D;&gt; Partial binary file found. Resuming download...&quot; binaryIncrementalDownload &quot;$&#123;BINARY_FILE&#125;&quot; &quot;$&#123;URL&#125;&quot; else curl &quot;$&#123;URL&#125;&quot; | tar xz || rc&#x3D;$? if [ -n &quot;$rc&quot; ]; then echo &quot;&#x3D;&#x3D;&gt; There was an error downloading the binary file. Switching to incremental download.&quot; echo &quot;&#x3D;&#x3D;&gt; Downloading file...&quot; binaryIncrementalDownload &quot;$&#123;BINARY_FILE&#125;&quot; &quot;$&#123;URL&#125;&quot; else echo &quot;&#x3D;&#x3D;&gt; Done.&quot; fi fi&#125; curl &quot;$&#123;URL&#125;&quot; | tar xz || rc=$? 使用curl命令下载tar包，并用tar命令解压。解压后的可执行文件出现在bin目录下，但由于下载过程网络原因，会花费较多时间或者下载失败。所以也可以通过编译fabric源码生成。通过编译生成二进制可执行文件的方式在上一篇fabric1.4下载安装中已经讲过。生成的可执行文件有configtxgen configtxlator cryptogen discover idemixgen orderer peer作用如下 文件 作用 configtxgen 负责生成配置的区块和配置交易 configtxlator 配置信息解读 cryptogen 负责生成组织和成员身份证明文件 discover fabric发现服务 idemixgen 身份混合机制 orderer 负责启动排序节点 peer 负责启动节点 2.3 dockerInstall12345678910111213141516171819dockerInstall() &#123; command -v docker &gt;&amp; &#x2F;dev&#x2F;null NODOCKER&#x3D;$? if [ &quot;$&#123;NODOCKER&#125;&quot; &#x3D;&#x3D; 0 ]; then echo &quot;&#x3D;&#x3D;&#x3D;&gt; Pulling fabric Images&quot; dockerFabricPull &quot;$&#123;FABRIC_TAG&#125;&quot; echo &quot;&#x3D;&#x3D;&#x3D;&gt; Pulling fabric ca Image&quot; dockerCaPull &quot;$&#123;CA_TAG&#125;&quot; echo &quot;&#x3D;&#x3D;&#x3D;&gt; Pulling thirdparty docker images&quot; dockerThirdPartyImagesPull &quot;$&#123;THIRDPARTY_TAG&#125;&quot; echo echo &quot;&#x3D;&#x3D;&#x3D;&gt; List out hyperledger docker images&quot; docker images | grep hyperledger else echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; echo &quot;Docker not installed, bypassing download of Fabric images&quot; echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; fi&#125; 关键下载语句如下所示： dockerFabricPull &quot;$&#123;FABRIC_TAG&#125;&quot; dockerCaPull &quot;$&#123;CA_TAG&#125;&quot; dockerThirdPartyImagesPull &quot;$&#123;THIRDPARTY_TAG&#125;&quot; 拉取对应的docker镜像并打标签，最后执行==docker images | grep hyperledger==查看是否下载完成所有镜像。 2.3.1 dockerFabricPull123456789101112# dockerFabricPull() pulls docker images from fabric and chaincode repositories# note, if a docker image doesn&#39;t exist for a requested release, it will simply# be skipped, since this script doesn&#39;t terminate upon errors.dockerFabricPull() &#123; local FABRIC_TAG&#x3D;$1 for IMAGES in peer orderer ccenv tools baseos nodeenv javaenv; do echo &quot;&#x3D;&#x3D;&gt; FABRIC IMAGE: $IMAGES&quot; echo docker pull &quot;hyperledger&#x2F;fabric-$IMAGES:$FABRIC_TAG&quot; docker tag &quot;hyperledger&#x2F;fabric-$IMAGES:$FABRIC_TAG&quot; &quot;hyperledger&#x2F;fabric-$IMAGES&quot; done&#125; 2.3.2 dockerCaPull1234567dockerCaPull() &#123; local CA_TAG&#x3D;$1 echo &quot;&#x3D;&#x3D;&gt; FABRIC CA IMAGE&quot; echo docker pull &quot;hyperledger&#x2F;fabric-ca:$CA_TAG&quot; docker tag &quot;hyperledger&#x2F;fabric-ca:$CA_TAG&quot; &quot;hyperledger&#x2F;fabric-ca&quot;&#125; 2.3.3 dockerThirdPartyImagesPull12345678910dockerThirdPartyImagesPull() &#123; local THIRDPARTY_TAG&#x3D;$1 for IMAGES in couchdb kafka zookeeper; do echo &quot;&#x3D;&#x3D;&gt; THIRDPARTY DOCKER IMAGE: $IMAGES&quot; echo docker pull &quot;hyperledger&#x2F;fabric-$IMAGES:$THIRDPARTY_TAG&quot; docker tag &quot;hyperledger&#x2F;fabric-$IMAGES:$THIRDPARTY_TAG&quot; &quot;hyperledger&#x2F;fabric-$IMAGES&quot; done&#125; 镜像说明 名称 说明 是否必需 hyperledger/fabric-peer peer节点镜像文件 是 hyperledger/fabric-orderer orderer节点镜像文件 是 hyperledger/fabric-ccenv GOLANG链码基础镜像文件 是 hyperledger/fabric-tools 包含crytogen、configtxgen、configtxlator等工具的镜像文件 否 hyperledger/fabric-ca fabric-ca镜像文件 否 hyperledger/fabric-couchdb couchdb镜像文件 否 hyperledger/fabric-kafka kafka镜像文件 否 hyperledger/fabric-zookeeper zookeeper镜像文件 否 hyperledger/fabric-javaenv java链码的基础镜像文件 否 注: 非必需的镜像文件说明只有在需要使用的时候选择即可"},{"title":"fabric1.4下载安装","date":"2019-10-21T07:59:40.000Z","path":"2019/10/21/fabric1-4-download/","text":"一. 通过脚本安装1. 创建安装目录1mkdir -p &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F; &amp;&amp; cd &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger 2. 克隆fabric-sample项目1git clone -b v1.4.3 https:&#x2F;&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples.git &amp;&amp; cd fabric-samples 3. 执行bootstrap脚本1curl -sSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;hyperledger&#x2F;fabric&#x2F;master&#x2F;scripts&#x2F;bootstrap.sh | bash -s -- 1.4.3 1.4.3 0.4.15 一般执行该命令会消耗较长时间，且可能出现下载失败，所以可以采取以下方式： 进入目录/opt/gopath/src/github.com/hyperledger，从github上拉取fabric源码 12345git clone https:&#x2F;&#x2F;gerrit.hyperledger.org&#x2F;r&#x2F;fabric.gitcd fabricgit checkout v1.4.3make releasecd release&#x2F;linux-amd64&#x2F;bin 若bin文件夹中出现以下文件说明编译成功 12[root@localhost bin]# lsconfigtxgen configtxlator cryptogen discover idemixgen orderer peer 将生成文件添加进环境变量 12vim &#x2F;etc&#x2F;profileexport PATH&#x3D;$PATH:$GOPATH&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;release&#x2F;linux-amd64&#x2F;bin wq保存退出，并更新 1source &#x2F;etc&#x2F;profile 二、手动下载安装1. 定义变量12345678910111213VERSION&#x3D;1.4.3CA_VERSION&#x3D;1.4.3THIRDPARTY_IMAGE_VERSION&#x3D;0.4.15CA_TAG&#x3D;$CA_VERSIONFABRIC_TAG&#x3D;$VERSIONTHIRDPARTY_TAG&#x3D;$THIRDPARTY_IMAGE_VERSIONARCH&#x3D;$(echo &quot;$(uname -s|tr &#39;[:upper:]&#39; &#39;[:lower:]&#39;|sed &#39;s&#x2F;mingw64_nt.*&#x2F;windows&#x2F;&#39;)-$(uname -m | sed &#39;s&#x2F;x86_64&#x2F;amd64&#x2F;g&#39;)&quot;)MARCH&#x3D;$(uname -m)BINARY_FILE&#x3D;hyperledger-fabric-$&#123;ARCH&#125;-$&#123;VERSION&#125;.tar.gzCA_BINARY_FILE&#x3D;hyperledger-fabric-ca-$&#123;ARCH&#125;-$&#123;CA_VERSION&#125;.tar.gz 2. 创建项目目录1mkdir -p &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F; &amp;&amp; cd &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger 3. 克隆fabric-sample，并切换到对应版本（可选）1git clone -b master https:&#x2F;&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-samples.git &amp;&amp; cd fabric-samples &amp;&amp; git checkout v$&#123;VERSION&#125; 4. 下载二进制可执行文件压缩包并解压4.1 通过链接下载压缩包并解压（很慢，耗时过长，且容易出现下载失败）123curl https:&#x2F;&#x2F;nexus.hyperledger.org&#x2F;content&#x2F;repositories&#x2F;releases&#x2F;org&#x2F;hyperledger&#x2F;fabric&#x2F;hyperledger-fabric&#x2F;$&#123;ARCH&#125;-$&#123;VERSION&#125;&#x2F;$&#123;BINARY_FILE&#125; | tar xzcurl https:&#x2F;&#x2F;nexus.hyperledger.org&#x2F;content&#x2F;repositories&#x2F;releases&#x2F;org&#x2F;hyperledger&#x2F;fabric-ca&#x2F;hyperledger-fabric-ca&#x2F;$&#123;ARCH&#125;-$&#123;CA_VERSION&#125;&#x2F;$&#123;CA_BINARY_FILE&#125; | tar xz 4.2 通过源码编译生成（建议使用该方法）1234567git clone https:&#x2F;&#x2F;gerrit.hyperledger.org&#x2F;r&#x2F;fabric.gitcd fabricgit checkout release-1.4make releasecd release&#x2F;linux-amd64&#x2F;bin[root@localhost bin]# lsconfigtxgen configtxlator cryptogen discover idemixgen orderer peer 1234567git clone https:&#x2F;&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-ca.gitcd fabric-cagit checkout v1.4.3make releasecd release&#x2F;linux-amd64&#x2F;bin[root@localhost bin]# lsfabric-ca-client 将生成文件移到同一个文件夹并添加进环境变量 123mv fabric-ca-client &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;release&#x2F;linux-amd64&#x2F;bin&#x2F;vim &#x2F;etc&#x2F;profileexport PATH&#x3D;$PATH:$GOPATH&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;release&#x2F;linux-amd64&#x2F;bin wq保存退出，并更新 1source &#x2F;etc&#x2F;profile 5. 拉取镜像5.1 拉取fabric镜像1234567891011121314151617181920docker pull &quot;hyperledger&#x2F;fabric-peer:$FABRIC_TAG&quot;docker tag &quot;hyperledger&#x2F;fabric-peer:$FABRIC_TAG&quot; &quot;hyperledger&#x2F;fabric-peer&quot;docker pull &quot;hyperledger&#x2F;fabric-orderer:$FABRIC_TAG&quot;docker tag &quot;hyperledger&#x2F;fabric-orderer:$FABRIC_TAG&quot; &quot;hyperledger&#x2F;fabric-orderer&quot;docker pull &quot;hyperledger&#x2F;fabric-ccenv:$FABRIC_TAG&quot;docker tag &quot;hyperledger&#x2F;fabric-ccenv:$FABRIC_TAG&quot; &quot;hyperledger&#x2F;fabric-ccenv&quot;docker pull &quot;hyperledger&#x2F;fabric-tools:$FABRIC_TAG&quot;docker tag &quot;hyperledger&#x2F;fabric-tools:$FABRIC_TAG&quot; &quot;hyperledger&#x2F;fabric-tools&quot;docker pull &quot;hyperledger&#x2F;fabric-baseos:$FABRIC_TAG&quot;docker tag &quot;hyperledger&#x2F;fabric-baseos:$FABRIC_TAG&quot; &quot;hyperledger&#x2F;fabric-baseos&quot;docker pull &quot;hyperledger&#x2F;fabric-nodeenv:$FABRIC_TAG&quot;docker tag &quot;hyperledger&#x2F;fabric-nodeenv:$FABRIC_TAG&quot; &quot;hyperledger&#x2F;fabric-nodeenv&quot;docker pull &quot;hyperledger&#x2F;fabric-javaenv:$FABRIC_TAG&quot;docker tag &quot;hyperledger&#x2F;fabric-javaenv:$FABRIC_TAG&quot; &quot;hyperledger&#x2F;fabric-javaenv&quot; 5.2 拉取第三方镜像12345678docker pull &quot;hyperledger&#x2F;fabric-couchdb:$THIRDPARTY_TAG&quot;docker tag &quot;hyperledger&#x2F;fabric-couchdb:$THIRDPARTY_TAG&quot; &quot;hyperledger&#x2F;fabric-couchdb&quot;docker pull &quot;hyperledger&#x2F;fabric-kafka:$THIRDPARTY_TAG&quot;docker tag &quot;hyperledger&#x2F;fabric-kafka:$THIRDPARTY_TAG&quot; &quot;hyperledger&#x2F;fabric-kafka&quot; docker pull &quot;hyperledger&#x2F;fabric-zookeeper:$THIRDPARTY_TAG&quot;docker tag &quot;hyperledger&#x2F;fabric-zookeeper:$THIRDPARTY_TAG&quot; &quot;hyperledger&#x2F;fabric-zookeeper&quot; 5.3 拉取fabric-ca镜像12docker pull &quot;hyperledger&#x2F;fabric-ca:$CA_TAG&quot;docker tag &quot;hyperledger&#x2F;fabric-ca:$CA_TAG&quot; &quot;hyperledger&#x2F;fabric-ca&quot; 拉取结果： 123456789101112131415161718[root@localhost ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhyperledger&#x2F;fabric-tools 1.4.3 18ed4db0cd57 7 weeks ago 1.55GBhyperledger&#x2F;fabric-tools latest 18ed4db0cd57 7 weeks ago 1.55GBhyperledger&#x2F;fabric-ca 1.4.3 c18a0d3cc958 7 weeks ago 253MBhyperledger&#x2F;fabric-ca latest c18a0d3cc958 7 weeks ago 253MBhyperledger&#x2F;fabric-ccenv 1.4.3 3d31661a812a 7 weeks ago 1.45GBhyperledger&#x2F;fabric-ccenv latest 3d31661a812a 7 weeks ago 1.45GBhyperledger&#x2F;fabric-orderer 1.4.3 b666a6ebbe09 7 weeks ago 173MBhyperledger&#x2F;fabric-orderer latest b666a6ebbe09 7 weeks ago 173MBhyperledger&#x2F;fabric-peer 1.4.3 fa87ccaed0ef 7 weeks ago 179MBhyperledger&#x2F;fabric-peer latest fa87ccaed0ef 7 weeks ago 179MBhyperledger&#x2F;fabric-zookeeper 0.4.15 20c6045930c8 7 months ago 1.43GBhyperledger&#x2F;fabric-zookeeper latest 20c6045930c8 7 months ago 1.43GBhyperledger&#x2F;fabric-kafka 0.4.15 b4ab82bbaf2f 7 months ago 1.44GBhyperledger&#x2F;fabric-kafka latest b4ab82bbaf2f 7 months ago 1.44GBhyperledger&#x2F;fabric-couchdb 0.4.15 8de128a55539 7 months ago 1.5GBhyperledger&#x2F;fabric-couchdb latest 8de128a55539 7 months ago 1.5GB 三、启动第一个fabric网络12cd &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-sample&#x2F;first-network.&#x2F;byfn up 若最后输出以下内容，说明fabric网络启动成功 12345678910&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Query successful on peer1.org2 on channel &#39;mychannel&#39; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; All GOOD, BYFN execution completed &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; _____ _ _ ____ | ____| | \\ | | | _ \\ | _| | \\| | | | | | | |___ | |\\ | | |_| | |_____| |_| \\_| |____&#x2F; 关闭启动的fabric网络，同时删除链码镜像 1.&#x2F;byfn down"},{"title":"问题1 ：curl 不支持 https（Protocol https not supported or disabled in libcurl）","date":"2019-10-21T07:50:10.000Z","path":"2019/10/21/prob1/","text":"curl默认安装完后是只支持http协议而不支持https协议的。 1、可以先用curl -V查看当前curl支持哪些协议：12345[root@localhost ~]# curl -Vcurl 7.66.0 (x86_64-pc-linux-gnu) libcurl&#x2F;7.66.0 OpenSSL&#x2F;1.0.2k zlib&#x2F;1.2.7Release-Date: 2019-09-11Protocols: dict file ftp ftps gopher http imap imaps pop3 pop3s rtsp smb smbs smtp smtps telnet tftp Features: AsynchDNS HTTPS-proxy IPv6 Largefile libz NTLM NTLM_WB SSL TLS-SRP UnixSockets 可以看到并不支持https协议。若用curl命令访问https时就会报错： Protocol https not supported or disabled in libcurl 若需要让curl支持https协议，需要安装openssl并在curl中使之生效： 2、下载并安装openssl包（若已经装了则不需要重新安装）：wget https://www.openssl.org/source/openssl-1.0.2k.tar.gz wget https://www.openssl.org/source/openssl-fips-2.0.14.tar.gz 安装openssl-fips： 12tar xvf openssl-fips-2.0.14.tar.gzcd openssl-fips-2.0.14 &amp;&amp; .&#x2F;config &amp;&amp; make &amp;&amp; make install 安装openssl： 12tar xvf openssl-1.0.2k.tar.gz.&#x2F;config shared --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ssl &amp;&amp; make &amp;&amp; make install 3、更新ld12echo &quot;&#x2F;usr&#x2F;local&#x2F;ssl&#x2F;lib&quot; &gt;&gt; &#x2F;etc&#x2F;ld.so.confldconfig -v 4、配置openssl库1234567891011cp &#x2F;usr&#x2F;local&#x2F;ssl&#x2F;lib&#x2F;libssl.so.1.0.0 &#x2F;usr&#x2F;lib64cp &#x2F;usr&#x2F;local&#x2F;ssl&#x2F;lib&#x2F;libcrypto.so.1.0.0 &#x2F;usr&#x2F;lib64chmod 555 &#x2F;usr&#x2F;lib64&#x2F;libssl.so.1.0.0chmod 555&#x2F;usr&#x2F;lib64&#x2F;libcrypto.so.1.0.0ln -s &#x2F;usr&#x2F;lib64&#x2F;libcrypto.so.1.0.0 &#x2F;usr&#x2F;lib64&#x2F;libcrypto.so.10ln -s &#x2F;usr&#x2F;lib64&#x2F;libssl.so.1.0.0 &#x2F;usr&#x2F;lib64&#x2F;libssl.so.10ln -s &#x2F;usr&#x2F;local&#x2F;ssl&#x2F;bin&#x2F;openssl &#x2F;usr&#x2F;bin&#x2F;opensslln -s&#x2F;usr&#x2F;local&#x2F;ssl&#x2F;include&#x2F;openssl &#x2F;usr&#x2F;include&#x2F;openssl 5、 查看openssl版本123456789openssl version -aOpenSSL 1.0.2k-fips 26 Jan 2017built on: reproducible build, date unspecifiedplatform: linux-x86_64options: bn(64,64) md2(int) rc4(16x,int) des(idx,cisc,16,int) idea(int) blowfish(idx) compiler: gcc -I. -I.. -I..&#x2F;include -fPIC -DOPENSSL_PIC -DZLIB -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -DKRB5_MIT -m64 -DL_ENDIAN -Wall -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE&#x3D;2 -fexceptions -fstack-protector-strong --param&#x3D;ssp-buffer-size&#x3D;4 -grecord-gcc-switches -m64 -mtune&#x3D;generic -Wa,--noexecstack -DPURIFY -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DRC4_ASM -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DWHIRLPOOL_ASM -DGHASH_ASM -DECP_NISTZ256_ASMOPENSSLDIR: &quot;&#x2F;etc&#x2F;pki&#x2F;tls&quot;engines: rdrand dynamic 6、重新编译curl123.&#x2F;configure –with-ssl&#x3D;&#x2F;usr&#x2F;local&#x2F;sslmakemake install 7、查看curl是否已经支持https协议：123456curl -V[root@localhost ~]# curl -Vcurl 7.66.0 (x86_64-pc-linux-gnu) libcurl&#x2F;7.66.0 OpenSSL&#x2F;1.0.2k zlib&#x2F;1.2.7Release-Date: 2019-09-11Protocols: dict file ftp ftps gopher http https imap imaps pop3 pop3s rtsp smb smbs smtp smtps telnet tftp Features: AsynchDNS HTTPS-proxy IPv6 Largefile libz NTLM NTLM_WB SSL TLS-SRP UnixSockets 可以看到已经支持https协议了。 内容参考PrefectSix"},{"title":"fabric1.4开发环境准备","date":"2019-10-21T07:36:45.000Z","path":"2019/10/21/fabric1-4-env/","text":"1.安装curl最新版本1234567wget https:&#x2F;&#x2F;curl.haxx.se&#x2F;download&#x2F;curl-7.66.0.tar.gztar -zxvf curl-7.66.0.tar.gzcd curl-7.66.0 yum install gcc gcc-c++ -y.&#x2F;configure make -j8 &amp;&amp; make install curl --version 2.安装docker更新yum包 1yum update 安装所需要软件包 1yum install -y yum-utils device-mapper-persistent-data lvm2 设置yum源 1yum-config-manager --add-repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo 查看仓库中的docker版本，安装特定版本 1yum list docker-ce --showduplicates | sort -r 安装docker，docker-ce-版本号 1yum install docker-ce-17.12.1.ce 启动docker 1systemctl start docker 加入开机启动 1systemctl enable docker 验证安装是否成功，若有client和server两部分说明安装启动成功 123456789101112131415161718[root@localhost ~]# docker version Client: Version: 17.12.1-ce API version: 1.35 Go version: go1.9.4 Git commit: 7390fc6 Built: Tue Feb 27 22:15:20 2018 OS&#x2F;Arch: linux&#x2F;amd64Server: Engine: Version: 17.12.1-ce API version: 1.35 (minimum version 1.12) Go version: go1.9.4 Git commit: 7390fc6 Built: Tue Feb 27 22:17:54 2018 OS&#x2F;Arch: linux&#x2F;amd64 Experimental: false 3.安装docker-compose安装python-pip 123yum -y install epel-releasepip install --upgrade pipyum install -y python-pip 安装docker-compose 12pip install docker-composedocker-compose --version 12345[root@localhost ~]# docker-compose versiondocker-compose version 1.24.1, build 4667896docker-py version: 3.7.3CPython version: 2.7.5OpenSSL version: OpenSSL 1.0.2k-fips 26 Jan 2017 4.安装golang12345678wget https:&#x2F;&#x2F;gomirrors.org&#x2F;dl&#x2F;go&#x2F;go1.11.10.linux-amd64.tar.gztar -C &#x2F;usr&#x2F;local -xzf go1.11.10.linux-amd64.tar.gzvim &#x2F;etc&#x2F;profile export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go export PATH&#x3D;$PATH:$GOROOT&#x2F;bin export GOPATH&#x3D;&#x2F;opt&#x2F;gopath source &#x2F;etc&#x2F;profile go version"},{"title":"fabric分布式部署方案","date":"2019-03-31T09:23:01.000Z","path":"2019/03/31/fabric-distribute-config/","text":"一、环境操作系统：CentOS 7.6软件版本 软件名称 版本号 hyperledger/fabric-ca（镜像） 1.2.0 hyperledger/fabric-orderer（镜像） 1.2.0 hyperledger/fabric-peer（镜像） 1.2.0 hyperledger/fabric-zookeeper（镜像） 1.2.0 hyperledger/fabric-kafka（镜像） 1.2.0 hyperledger/fabric-tools（镜像） 1.2.0 hyperledger/fabric-ccenv（镜像） 1.2.0 docker 1.13.1 docker-compose 1.12.0 go 1.11.2 ip 部署角色 191.8.2.156 ca0 &nbsp; &nbsp; zookeeper0 &nbsp; &nbsp;kafka0 &nbsp; &nbsp; orderer0.example.com &nbsp; &nbsp; peer0.org1.example.com 191.8.2.158 zookeeper1 &nbsp; &nbsp; kafka1 &nbsp; &nbsp; orderer1.example.com 191.8.2.159 zookeeper2 &nbsp; &nbsp; kafka2 &nbsp; &nbsp; orderer2.example.com &nbsp; &nbsp; peer0.org2.example.com 191.8.2.147 kafka3 &nbsp; &nbsp; peer1.org2.example.com 191.8.2.148 ca1 &nbsp; &nbsp; peer1.org1.example.com 二、fabric网络结构本次分布式部署包括以下节点角色： 3个orderer 2个组织org1、org2 4个peer，每个组织包含2个peer，分别为peer0.org1、peer1.org1、peer0.org2、peer1.org2 2个CA，每个组织包含一个CA，分别是ca0、ca1 3个zookeeper实例，zookeeper0、zookeeper1、zookeeper2 4个kafka实例，kafka0、kafka1、kafka2、kafka3 三、部署过程1、生成创世区块、channel、锚节点和证书及密钥所需材料生成创世区块、channel、锚节点所需配置文件 configtx.yaml 生成证书及密钥文件所需材料 crypto-config.yaml 运行文件 generate.sh使用工具 configtxgen 和cryptogen来生成对应材料 1bash generate.sh 该命令执行完会生成两个文件目录config、cryto-config 将config文件和cryto-config文件压缩打包 123zip -r .&#x2F; config .&#x2F;config.zipzip -r .&#x2F; crypto-config .&#x2F; crypto-config.zip 2、在每个宿主机上创建新路径用来存放fabric项目12mkdir &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F; &amp;&amp; cd &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F; 3、将步骤1的压缩文件分发到各个节点fabric项目目录目录下并解压123456789101112scp config.zip root@191.8.2.158 :&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;scp crypto-config.zip root@191.8.2.158: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;scp config.zip root@191.8.2.159: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;scp crypto-config.zip root@191.8.2.159: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;scp config.zip root@191.8.2.148: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;scp crypto-config.zip root@191.8.2.148: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;scp config.zip root@191.8.2.148: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;scp crypto-config.zip root@191.8.2.148: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F; 解压 1234cd &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;unzip config.zipunzip crypto-config.zip 4、编写各节点角色容器启动文件4.1 在每个宿主机路径/opt/gopath/src/github.com/hyperledger/下创建hosts文件，该host是文件主要是作为挂载在容器的hosts文件 1234567mkdir cluster-config &amp;&amp; cd cluster-configvi hosts 191.8.2.156 ca0 zookeeper0 kafka0 orderer0.example.com peer0.org1.example.com 191.8.2.158 zookeeper1 kafka1 orderer1.example.com peer1.org1.example.com 191.8.2.159 zookeeper2 kafka2 orderer2.example.com peer0.org2.example.com 191.8.2.147 kafka3 peer1.org2.example.com 191.8.2.148 ca1 peer1.org1.example.com 创建docker-compose-base.yml文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100vi docker-compose-base.ymlversion: &#39;2&#39;services: zookeeper: image: hyperledger&#x2F;fabric-zookeeper ports: - 2181 - 2888 - 3888 volumes: - .&#x2F;hosts:&#x2F;etc&#x2F;hosts kafka: image: hyperledger&#x2F;fabric-kafka environment: - KAFKA_LOG_RETENTION_MS&#x3D;-1 - KAFKA_MESSAGE_MAX_BYTES&#x3D;103809024 - KAFKA_REPLICA_FETCH_MAX_BYTES&#x3D;103809024 - KAFKA_UNCLEAN_LEADER_ELECTION_ENABLE&#x3D;false - KAFKA_DEFAULT_REPLICATION_FACTOR&#x3D;$&#123;KAFKA_DEFAULT_REPLICATION_FACTOR&#125; - KAFKA_MIN_INSYNC_REPLICAS&#x3D;2 volumes: - .&#x2F;hosts:&#x2F;etc&#x2F;hosts ports: - 9092 orderer: image: hyperledger&#x2F;fabric-orderer environment: - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE&#x3D;host - ORDERER_HOME&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;orderer - ORDERER_GENERAL_LOGLEVEL&#x3D;debug - ORDERER_GENERAL_LOCALMSPDIR&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;msp - ORDERER_GENERAL_LOCALMSPID&#x3D;OrdererMSP - ORDERER_GENERAL_LISTENADDRESS&#x3D;0.0.0.0 - ORDERER_GENERAL_LISTENPORT&#x3D;7050 - ORDERER_GENERAL_LEDGERTYPE&#x3D;ram - ORDERER_GENERAL_GENESISMETHOD&#x3D;file - ORDERER_GENERAL_GENESISFILE&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;configs&#x2F;orderer.block - CONFIGTX_ORDERER_ORDERERTYPE&#x3D;solo - CONFIGTX_ORDERER_BATCHSIZE_MAXMESSAGECOUNT&#x3D;$&#123;CONFIGTX_ORDERER_BATCHSIZE_MAXMESSAGECOUNT&#125; - CONFIGTX_ORDERER_BATCHTIMEOUT&#x3D;$&#123;CONFIGTX_ORDERER_BATCHTIMEOUT&#125; - CONFIGTX_ORDERER_ADDRESSES&#x3D;[127.0.0.1:7050] # TLS settings - ORDERER_GENERAL_TLS_ENABLED&#x3D;$&#123;ORDERER_GENERAL_TLS_ENABLED&#125; - ORDERER_GENERAL_TLS_PRIVATEKEY&#x3D;$&#123;ORDERER_GENERAL_TLS_PRIVATEKEY&#125; - ORDERER_GENERAL_TLS_CERTIFICATE&#x3D;$&#123;ORDERER_GENERAL_TLS_CERTIFICATE&#125; - ORDERER_GENERAL_TLS_ROOTCAS&#x3D;[&#x2F;var&#x2F;hyperledger&#x2F;tls&#x2F;ca.crt] - ORDERER_TLS_CLIENTAUTHREQUIRED&#x3D;$&#123;ORDERER_TLS_CLIENTAUTHREQUIRED&#125; - ORDERER_TLS_CLIENTROOTCAS_FILES&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;users&#x2F;Admin@example.com&#x2F;tls&#x2F;ca.crt - ORDERER_TLS_CLIENTCERT_FILE&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;users&#x2F;Admin@example.com&#x2F;tls&#x2F;client.crt - ORDERER_TLS_CLIENTKEY_FILE&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;users&#x2F;Admin@example.com&#x2F;tls&#x2F;client.key volumes: - ..&#x2F;config&#x2F;:&#x2F;var&#x2F;hyperledger&#x2F;configs - ..&#x2F;crypto-config&#x2F;ordererOrganizations&#x2F;example.com&#x2F;users:&#x2F;var&#x2F;hyperledger&#x2F;users - .&#x2F;hosts:&#x2F;etc&#x2F;hosts working_dir: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;orderer command: orderer ports: - &#39;7050&#39; couchdb: image: hyperledger&#x2F;fabric-couchdb volumes: - .&#x2F;hosts:&#x2F;etc&#x2F;hosts peer: image: hyperledger&#x2F;fabric-peer environment: - CORE_VM_ENDPOINT&#x3D;unix:&#x2F;&#x2F;&#x2F;host&#x2F;var&#x2F;run&#x2F;docker.sock - CORE_PEER_NETWORKID&#x3D;$&#123;CORE_PEER_NETWORKID&#125; - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE&#x3D;$&#123;CORE_PEER_NETWORKID&#125;_behave - CORE_PEER_ADDRESSAUTODETECT&#x3D;true - CORE_PEER_GOSSIP_ORGLEADER&#x3D;false - CORE_PEER_GOSSIP_USELEADERELECTION&#x3D;true - CORE_PEER_PROFILE_ENABLED&#x3D;true - CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;msp #- CORE_LEDGER_STATE_STATEDATABASE&#x3D;LevelDB - CORE_LOGGING_LEVEL&#x3D;DEBUG - CORE_LOGGING_GOSSIP&#x3D;$&#123;CORE_LOGGING_GOSSIP&#125; - CORE_LOGGING_MSP&#x3D;DEBUG # TLS settings - CORE_PEER_TLS_ENABLED&#x3D;$&#123;CORE_PEER_TLS_ENABLED&#125; - CORE_PEER_TLS_CLIENTAUTHREQUIRED&#x3D;$&#123;CORE_PEER_TLS_CLIENTAUTHREQUIRED&#125; - CORE_PEER_TLS_CERT_FILE&#x3D;$&#123;CORE_PEER_TLS_CERT_FILE&#125; - CORE_PEER_TLS_KEY_FILE&#x3D;$&#123;CORE_PEER_TLS_KEY_FILE&#125; - CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;tls&#x2F;ca.crt volumes: - &#x2F;var&#x2F;run&#x2F;:&#x2F;host&#x2F;var&#x2F;run&#x2F; - $GOPATH&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F; - ..&#x2F;crypto-config&#x2F;:&#x2F;var&#x2F;hyperledger&#x2F;configs - ..&#x2F;config&#x2F;:&#x2F;var&#x2F;hyperledger&#x2F;configs command: peer node start ports: - &#39;7051&#39; - &#39;7053&#39; 4.2 在各个宿主机上创建启动文件 实验过程中，zookeeper原本以默认网络模式启动，即与peer一样用默认网络配置，结果zookeeper之间无法联通，因此采用“host”网络模式启动，即在启动文件中使用**network_mode: “host”**。本实验中除了peer用默认网络配置启动之外，其它角色均使用“host”模式启动。 如果仅仅是zookeeper和kafka使用“host”模式启动应该也是可以的。 cli容器启动应该与peer容器处于同一网络模式中 4.2.1 宿主机191.8.2.156创建ca0.yml，其中文件中的c54f5a53707de15a9530d1f5bd492e5b2a626b67acd400b61f24d22b9fd06e69_sk 应该随着新生成的证书密钥文件作对应修改 1234567891011121314151617181920212223242526272829vi ca0.ymlversion: &#39;2&#39;# networks:# behave:services: ca0: image: hyperledger&#x2F;fabric-ca:$IMAGE_TAG environment: - FABRIC_CA_HOME&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric-ca-server - FABRIC_CA_SERVER_CA_NAME&#x3D;ca-org1 - FABRIC_CA_SERVER_TLS_ENABLED&#x3D;false - FABRIC_CA_SERVER_TLS_CERTFILE&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric-ca-server-config&#x2F;ca.org1.example.com-cert.pem - FABRIC_CA_SERVER_TLS_KEYFILE&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric-ca-server-config&#x2F;c54f5a53707de15a9530d1f5bd492e5b2a626b67acd400b61f24d22b9fd06e69_sk #该文件名应该对应着新生成的密钥文件进行修改 ports: - &quot;7054:7054&quot; command: sh -c &#39;fabric-ca-server start --ca.certfile &#x2F;etc&#x2F;hyperledger&#x2F;fabric-ca-server-config&#x2F;ca.org1.example.com-cert.pem --ca.keyfile &#x2F;etc&#x2F;hyperledger&#x2F;fabric-ca-server-config&#x2F;c54f5a53707de15a9530d1f5bd492e5b2a626b67acd400b61f24d22b9fd06e69_sk -b admin:adminpw -d&#39; #该文件名应该对应着新生成的密钥文件进行修改 volumes: - ..&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;ca&#x2F;:&#x2F;etc&#x2F;hyperledger&#x2F;fabric-ca-server-config - .&#x2F;hosts:&#x2F;etc&#x2F;hosts container_name: ca_peerOrg1 network_mode: &quot;host&quot; # networks: # behave: # aliases: # - $&#123;CORE_PEER_NETWORKID&#125; 创建zookeeper0.yml 12345678910111213141516171819202122vi zookeeper0.ymlversion: &#39;2&#39;# networks:# behave:services: zookeeper0: extends: file: docker-compose-base.yml service: zookeeper container_name: zookeeper0 environment: - ZOO_MY_ID&#x3D;1 - ZOO_SERVERS&#x3D;server.1&#x3D;zookeeper0:2888:3888 server.2&#x3D;zookeeper1:2888:3888 server.3&#x3D;zookeeper2:2888:3888 network_mode: &quot;host&quot; # networks: # behave: # aliases: # - $&#123;CORE_PEER_NETWORKID&#125; 创建kafka0.yml 123456789101112131415161718192021222324252627vi kafka0.ymlversion: &#39;2&#39;# networks:# behave:services: kafka0: extends: file: docker-compose-base.yml service: kafka container_name: kafka0 environment: - KAFKA_BROKER_ID&#x3D;0 - KAFKA_ZOOKEEPER_CONNECT&#x3D;zookeeper0:2181,zookeeper1:2181,zookeeper2:2181 - KAFKA_MESSAGE_MAX_BYTES&#x3D;$&#123;KAFKA_MESSAGE_MAX_BYTES&#125; - KAFKA_REPLICA_FETCH_MAX_BYTES&#x3D;$&#123;KAFKA_REPLICA_FETCH_MAX_BYTES&#125; - KAFKA_REPLICA_FETCH_RESPONSE_MAX_BYTES&#x3D;$&#123;KAFKA_REPLICA_FETCH_RESPONSE_MAX_BYTES&#125; ports: - &quot;9092:9092&quot; network_mode: &quot;host&quot; # networks: # behave: # aliases: # - $&#123;CORE_PEER_NETWORKID&#125; 创建orderer0.yml 1234567891011121314151617181920212223242526272829303132333435vi orderer0.ymlversion: &#39;2&#39;# networks:# behave:services: orderer0.example.com: extends: file: docker-compose-base.yml service: orderer container_name: orderer0.example.com environment: - ORDERER_HOST&#x3D;orderer0.example.com - CONFIGTX_ORDERER_ORDERERTYPE&#x3D;kafka - CONFIGTX_ORDERER_KAFKA_BROKERS&#x3D;[kafka0:9092,kafka1:9092,kafka2:9092,kafka3:9092] - ORDERER_KAFKA_RETRY_SHORTINTERVAL&#x3D;1s - ORDERER_KAFKA_RETRY_SHORTTOTAL&#x3D;30s - ORDERER_KAFKA_VERBOSE&#x3D;true - ORDERER_GENERAL_GENESISPROFILE&#x3D;SampleInsecureKafka - ORDERER_ABSOLUTEMAXBYTES&#x3D;$&#123;ORDERER_ABSOLUTEMAXBYTES&#125; - ORDERER_PREFERREDMAXBYTES&#x3D;$&#123;ORDERER_PREFERREDMAXBYTES&#125; volumes: - ..&#x2F;crypto-config&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer0.example.com&#x2F;msp:&#x2F;var&#x2F;hyperledger&#x2F;msp - ..&#x2F;crypto-config&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer0.example.com&#x2F;tls:&#x2F;var&#x2F;hyperledger&#x2F;tls - ..&#x2F;config&#x2F;:&#x2F;var&#x2F;hyperledger&#x2F;configs network_mode: &quot;host&quot; ports: - 7050:7050 # networks: # behave: # aliases: # - $&#123;CORE_PEER_NETWORKID&#125; 创建peer01.yml 123456789101112131415161718192021222324252627282930313233343536373839404142vi peer01.ymlversion: &#39;2&#39;networks: behave:services: peer0.org1.example.com: extends: file: docker-compose-base.yml service: peer container_name: peer0.org1.example.com environment: - CORE_PEER_CHAINCODELISTENADDRESS&#x3D;peer0.org1.example.com:7052 - CORE_PEER_ID&#x3D;peer0.org1.example.com - CORE_PEER_ADDRESS&#x3D;peer0.org1.example.com:7051 - CORE_PEER_GOSSIP_BOOTSTRAP&#x3D;peer1.org1.example.com:7051 - CORE_PEER_GOSSIP_EXTERNALENDPOINT&#x3D;peer0.org1.example.com:7051 - CORE_PEER_GOSSIP_ORGLEADER&#x3D;$&#123;CORE_PEER_GOSSIP_ORGLEADER_PEER0_ORG1&#125; - CORE_PEER_GOSSIP_USELEADERELECTION&#x3D;$&#123;CORE_PEER_GOSSIP_USELEADERELECTION_PEER0_ORG1&#125; - CORE_PEER_LOCALMSPID&#x3D;Org1MSP - CORE_PEER_TLS_CLIENTROOTCAS_FILES&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;users&#x2F;Admin@org1.example.com&#x2F;tls&#x2F;ca.crt - CORE_PEER_TLS_CLIENTCERT_FILE&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;users&#x2F;Admin@org1.example.com&#x2F;tls&#x2F;client.crt - CORE_PEER_TLS_CLIENTKEY_FILE&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;users&#x2F;Admin@org1.example.com&#x2F;tls&#x2F;client.key volumes: - ..&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer0.org1.example.com&#x2F;msp:&#x2F;var&#x2F;hyperledger&#x2F;msp - ..&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer0.org1.example.com&#x2F;tls:&#x2F;var&#x2F;hyperledger&#x2F;tls - ..&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users:&#x2F;var&#x2F;hyperledger&#x2F;users - ..&#x2F;config&#x2F;:&#x2F;var&#x2F;hyperledger&#x2F;configs extra_hosts: - &quot;orderer0.example.com:191.8.2.156&quot; - &quot;orderer1.example.com:191.8.2.158&quot; - &quot;orderer2.example.com:191.8.2.159&quot; networks: behave: aliases: - $&#123;CORE_PEER_NETWORKID&#125; ports: - 7051:7051 - 7053:7053 创建docker-compose-cli-org1.yml 123456789101112131415161718192021222324252627282930vi docker-compose-cli-org1.ymlversion: &#39;2&#39;networks: behave:services: cli: container_name: cli image: hyperledger&#x2F;fabric-tools tty: true environment: - GOPATH&#x3D;&#x2F;opt&#x2F;gopath - CORE_VM_ENDPOINT&#x3D;unix:&#x2F;&#x2F;&#x2F;host&#x2F;var&#x2F;run&#x2F;docker.sock - CORE_LOGGING_LEVEL&#x3D;DEBUG - CORE_PEER_ID&#x3D;cli - CORE_PEER_ADDRESS&#x3D;peer0.org1.example.com:7051 - CORE_PEER_LOCALMSPID&#x3D;Org1MSP - CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp - CORE_CHAINCODE_KEEPALIVE&#x3D;10 working_dir: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer command: &#x2F;bin&#x2F;bash volumes: - &#x2F;var&#x2F;run&#x2F;:&#x2F;host&#x2F;var&#x2F;run&#x2F; - ..&#x2F;chaincode&#x2F;:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;chaincode - $GOPATH&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F; - ..&#x2F;crypto-config:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F; networks: - behave 4.2.2 宿主机191.8.2.158创建zookeeper1.yml 1234567891011121314151617181920212223242526vi zookeeper1.ymlversion: &#39;2&#39;# networks:# behave:services: zookeeper1: extends: file: docker-compose-base.yml service: zookeeper container_name: zookeeper1 environment: - ZOO_MY_ID&#x3D;2 - ZOO_SERVERS&#x3D;server.1&#x3D;zookeeper0:2888:3888 server.2&#x3D;zookeeper1:2888:3888 server.3&#x3D;zookeeper2:2888:3888 ports: - &quot;2181:2181&quot; - &quot;2888:2888&quot; - &quot;3888:3888&quot; network_mode: &quot;host&quot; # networks: # behave: # aliases: # - $&#123;CORE_PEER_NETWORKID&#125; 创建kafka1.yml 12345678910111213141516171819202122232425262728vi kafka1.ymlversion: &#39;2&#39;# networks:# behave:services: kafka1: extends: file: docker-compose-base.yml service: kafka container_name: kafka1 environment: - KAFKA_ADVERTISED_HOST_NAME&#x3D;kafka1 - KAFKA_BROKER_ID&#x3D;1 - KAFKA_ZOOKEEPER_CONNECT&#x3D;zookeeper0:2181,zookeeper1:2181,zookeeper2:2181 - KAFKA_MESSAGE_MAX_BYTES&#x3D;$&#123;KAFKA_MESSAGE_MAX_BYTES&#125; - KAFKA_REPLICA_FETCH_MAX_BYTES&#x3D;$&#123;KAFKA_REPLICA_FETCH_MAX_BYTES&#125; - KAFKA_REPLICA_FETCH_RESPONSE_MAX_BYTES&#x3D;$&#123;KAFKA_REPLICA_FETCH_RESPONSE_MAX_BYTES&#125; ports: - &quot;9092:9092&quot; network_mode: &quot;host&quot; # networks: # behave: # aliases: # - $&#123;CORE_PEER_NETWORKID&#125; 创建orderer1.yml 12345678910111213141516171819202122232425262728293031323334353637vi orderer1.ymlversion: &#39;2&#39;# networks:# behave:services: orderer1.example.com: extends: file: docker-compose-base.yml service: orderer container_name: orderer1.example.com environment: - ORDERER_HOST&#x3D;orderer1.example.com - CONFIGTX_ORDERER_ORDERERTYPE&#x3D;kafka - CONFIGTX_ORDERER_KAFKA_BROKERS&#x3D;[kafka0:9092,kafka1:9092,kafka2:9092,kafka3:9092] - ORDERER_KAFKA_RETRY_SHORTINTERVAL&#x3D;1s - ORDERER_KAFKA_RETRY_SHORTTOTAL&#x3D;30s - ORDERER_KAFKA_RETRY_LONGINTERVAL&#x3D;30s - ORDERER_KAFKA_RETRY_LONGTOTAL&#x3D;5m - ORDERER_KAFKA_VERBOSE&#x3D;true - ORDERER_GENERAL_GENESISPROFILE&#x3D;SampleInsecureKafka - ORDERER_ABSOLUTEMAXBYTES&#x3D;$&#123;ORDERER_ABSOLUTEMAXBYTES&#125; - ORDERER_PREFERREDMAXBYTES&#x3D;$&#123;ORDERER_PREFERREDMAXBYTES&#125; volumes: - ..&#x2F;crypto-config&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer1.example.com&#x2F;msp:&#x2F;var&#x2F;hyperledger&#x2F;msp - ..&#x2F;crypto-config&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer1.example.com&#x2F;tls:&#x2F;var&#x2F;hyperledger&#x2F;tls - ..&#x2F;config&#x2F;:&#x2F;var&#x2F;hyperledger&#x2F;configs network_mode: &quot;host&quot; ports: - 7050:7050 # networks: # behave: # aliases: # - $&#123;CORE_PEER_NETWORKID&#125; 4.2.3 宿主机191.8.2.159创建zookeeper2.yml 1234567891011121314151617181920212223242526vi zookeeper2.ymlversion: &#39;2&#39;# networks:# behave:services: zookeeper2: extends: file: docker-compose-base.yml service: zookeeper container_name: zookeeper2 environment: - ZOO_MY_ID&#x3D;3 - ZOO_SERVERS&#x3D;server.1&#x3D;zookeeper0:2888:3888 server.2&#x3D;zookeeper1:2888:3888 server.3&#x3D;zookeeper2:2888:3888 ports: - &quot;2181:2181&quot; - &quot;2888:2888&quot; - &quot;3888:3888&quot; network_mode: &quot;host&quot; # networks: # behave: # aliases: # - $&#123;CORE_PEER_NETWORKID&#125; 创建kafka2.yml 12345678910111213141516171819202122232425262728vi kafka2.ymlversion: &#39;2&#39;# networks:# behave:services: kafka2: extends: file: docker-compose-base.yml service: kafka container_name: kafka2 environment: - KAFKA_ADVERTISED_HOST_NAME&#x3D;kafka2 - KAFKA_BROKER_ID&#x3D;2 - KAFKA_ZOOKEEPER_CONNECT&#x3D;zookeeper0:2181,zookeeper1:2181,zookeeper2:2181 - KAFKA_MESSAGE_MAX_BYTES&#x3D;$&#123;KAFKA_MESSAGE_MAX_BYTES&#125; - KAFKA_REPLICA_FETCH_MAX_BYTES&#x3D;$&#123;KAFKA_REPLICA_FETCH_MAX_BYTES&#125; - KAFKA_REPLICA_FETCH_RESPONSE_MAX_BYTES&#x3D;$&#123;KAFKA_REPLICA_FETCH_RESPONSE_MAX_BYTES&#125; ports: - &quot;9092:9092&quot; network_mode: &quot;host&quot; # networks: # behave: # aliases: # - $&#123;CORE_PEER_NETWORKID&#125; 创建orderer2.yml 1234567891011121314151617181920212223242526272829303132333435vi orderer2.ymlversion: &#39;2&#39;# networks:# behave:services: orderer2.example.com: extends: file: docker-compose-base.yml service: orderer container_name: orderer2.example.com environment: - ORDERER_HOST&#x3D;orderer2.example.com - CONFIGTX_ORDERER_ORDERERTYPE&#x3D;kafka - CONFIGTX_ORDERER_KAFKA_BROKERS&#x3D;[kafka0:9092,kafka1:9092,kafka2:9092,kafka3:9092] - ORDERER_KAFKA_RETRY_SHORTINTERVAL&#x3D;1s - ORDERER_KAFKA_RETRY_SHORTTOTAL&#x3D;30s - ORDERER_KAFKA_VERBOSE&#x3D;true - ORDERER_GENERAL_GENESISPROFILE&#x3D;SampleInsecureKafka - ORDERER_ABSOLUTEMAXBYTES&#x3D;$&#123;ORDERER_ABSOLUTEMAXBYTES&#125; - ORDERER_PREFERREDMAXBYTES&#x3D;$&#123;ORDERER_PREFERREDMAXBYTES&#125; volumes: - ..&#x2F;crypto-config&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer2.example.com&#x2F;msp:&#x2F;var&#x2F;hyperledger&#x2F;msp - ..&#x2F;crypto-config&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer2.example.com&#x2F;tls:&#x2F;var&#x2F;hyperledger&#x2F;tls - ..&#x2F;config&#x2F;:&#x2F;var&#x2F;hyperledger&#x2F;configs network_mode: &quot;host&quot; ports: - 7050:7050 # networks: # behave: # aliases: # - $&#123;CORE_PEER_NETWORKID&#125; 创建peer02.yml 123456789101112131415161718192021222324252627282930313233343536373839404142vi peer02.ymlversion: &#39;2&#39;networks: behave:services: peer0.org2.example.com: extends: file: docker-compose-base.yml service: peer container_name: peer0.org2.example.com environment: - CORE_PEER_CHAINCODELISTENADDRESS&#x3D;peer0.org2.example.com:7052 - CORE_PEER_ID&#x3D;peer0.org2.example.com - CORE_PEER_ADDRESS&#x3D;peer0.org2.example.com:7051 - CORE_PEER_GOSSIP_BOOTSTRAP&#x3D;peer1.org2.example.com:7051 - CORE_PEER_GOSSIP_EXTERNALENDPOINT&#x3D;peer0.org2.example.com:7051 - CORE_PEER_GOSSIP_ORGLEADER&#x3D;$&#123;CORE_PEER_GOSSIP_ORGLEADER_PEER0_ORG2&#125; - CORE_PEER_GOSSIP_USELEADERELECTION&#x3D;$&#123;CORE_PEER_GOSSIP_USELEADERELECTION_PEER0_ORG2&#125; - CORE_PEER_LOCALMSPID&#x3D;Org2MSP - CORE_PEER_TLS_CLIENTROOTCAS_FILES&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;users&#x2F;Admin@org2.example.com&#x2F;tls&#x2F;ca.crt - CORE_PEER_TLS_CLIENTCERT_FILE&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;users&#x2F;Admin@org2.example.com&#x2F;tls&#x2F;client.crt - CORE_PEER_TLS_CLIENTKEY_FILE&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;users&#x2F;Admin@org2.example.com&#x2F;tls&#x2F;client.key volumes: - ..&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;peers&#x2F;peer0.org2.example.com&#x2F;msp:&#x2F;var&#x2F;hyperledger&#x2F;msp - ..&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;peers&#x2F;peer0.org2.example.com&#x2F;tls:&#x2F;var&#x2F;hyperledger&#x2F;tls - ..&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;users:&#x2F;var&#x2F;hyperledger&#x2F;users - ..&#x2F;config&#x2F;:&#x2F;var&#x2F;hyperledger&#x2F;configs extra_hosts: - &quot;orderer0.example.com:191.8.2.156&quot; - &quot;orderer1.example.com:191.8.2.158&quot; - &quot;orderer2.example.com:191.8.2.159&quot; networks: behave: aliases: - $&#123;CORE_PEER_NETWORKID&#125; ports: - 7051:7051 - 7053:7053 4.2.4 宿主机191.8.2.147创建kafka3.yml 1234567891011121314151617181920212223242526272829vi kafka3.ymlversion: &#39;2&#39;# networks:# behave:services: kafka3: extends: file: docker-compose-base.yml service: kafka container_name: kafka3 environment: - KAFKA_ADVERTISED_HOST_NAME&#x3D;kafka3 - KAFKA_BROKER_ID&#x3D;3 - KAFKA_ZOOKEEPER_CONNECT&#x3D;zookeeper0:2181,zookeeper1:2181,zookeeper2:2181 - KAFKA_MESSAGE_MAX_BYTES&#x3D;$&#123;KAFKA_MESSAGE_MAX_BYTES&#125; - KAFKA_REPLICA_FETCH_MAX_BYTES&#x3D;$&#123;KAFKA_REPLICA_FETCH_MAX_BYTES&#125; - KAFKA_REPLICA_FETCH_RESPONSE_MAX_BYTES&#x3D;$&#123;KAFKA_REPLICA_FETCH_RESPONSE_MAX_BYTES&#125; ports: - &quot;9092:9092&quot; network_mode: &quot;host&quot; # networks: # behave: # aliases: # - $&#123;CORE_PEER_NETWORKID&#125; 创建peer12.yml 12345678910111213141516171819202122232425262728293031323334353637383940414243vi peer12.ymlversion: &#39;2&#39;networks: behave:services: peer1.org2.example.com: extends: file: docker-compose-base.yml service: peer container_name: peer1.org2.example.com environment: - CORE_PEER_CHAINCODELISTENADDRESS&#x3D;peer1.org2.example.com:7052 - CORE_PEER_ID&#x3D;peer1.org2.example.com - CORE_PEER_ADDRESS&#x3D;peer1.org2.example.com:7051 - CORE_PEER_GOSSIP_BOOTSTRAP&#x3D;peer0.org2.example.com:7051 - CORE_PEER_GOSSIP_ORGLEADER&#x3D;$&#123;CORE_PEER_GOSSIP_ORGLEADER_PEER1_ORG2&#125; - CORE_PEER_GOSSIP_USELEADERELECTION&#x3D;$&#123;CORE_PEER_GOSSIP_USELEADERELECTION_PEER1_ORG2&#125; - CORE_PEER_LOCALMSPID&#x3D;Org2MSP - CORE_PEER_TLS_CLIENTROOTCAS_FILES&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;users&#x2F;Admin@org2.example.com&#x2F;tls&#x2F;ca.crt - CORE_PEER_TLS_CLIENTCERT_FILE&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;users&#x2F;Admin@org2.example.com&#x2F;tls&#x2F;client.crt - CORE_PEER_TLS_CLIENTKEY_FILE&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;users&#x2F;Admin@org2.example.com&#x2F;tls&#x2F;client.key volumes: - ..&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;peers&#x2F;peer1.org2.example.com&#x2F;msp:&#x2F;var&#x2F;hyperledger&#x2F;msp - ..&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;peers&#x2F;peer1.org2.example.com&#x2F;tls:&#x2F;var&#x2F;hyperledger&#x2F;tls - ..&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;users:&#x2F;var&#x2F;hyperledger&#x2F;users - ..&#x2F;config&#x2F;:&#x2F;var&#x2F;hyperledger&#x2F;configs extra_hosts: - &quot;orderer0.example.com:191.8.2.156&quot; - &quot;orderer1.example.com:191.8.2.158&quot; - &quot;orderer2.example.com:191.8.2.159&quot; - &quot;peer0.org2.example.com:191.8.2.159&quot; networks: behave: aliases: - $&#123;CORE_PEER_NETWORKID&#125; ports: - 7051:7051 - 7053:7053 4.2.5 宿主机191.8.2.148创建ca1.yml，其中文件中的4eda5b173fa1151ce140d538ba5135f6459d383c989b37836e2b687cdf0f2b72_sk 应该随着新生成的证书密钥文件作对应修改 1234567891011121314151617181920212223242526272829vi ca1.ymlversion: &#39;2&#39;# networks:# behave:services: ca1: image: hyperledger&#x2F;fabric-ca:$IMAGE_TAG environment: - FABRIC_CA_HOME&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric-ca-server - FABRIC_CA_SERVER_CA_NAME&#x3D;ca-org2 - FABRIC_CA_SERVER_TLS_ENABLED&#x3D;false - FABRIC_CA_SERVER_TLS_CERTFILE&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric-ca-server-config&#x2F;ca.org2.example.com-cert.pem - FABRIC_CA_SERVER_TLS_KEYFILE&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric-ca-server-config&#x2F;4eda5b173fa1151ce140d538ba5135f6459d383c989b37836e2b687cdf0f2b72_sk #该文件名应该对应着新生成的密钥文件进行修改 ports: - &quot;7054:7054&quot; command: sh -c &#39;fabric-ca-server start --ca.certfile &#x2F;etc&#x2F;hyperledger&#x2F;fabric-ca-server-config&#x2F;ca.org2.example.com-cert.pem --ca.keyfile &#x2F;etc&#x2F;hyperledger&#x2F;fabric-ca-server-config&#x2F;4eda5b173fa1151ce140d538ba5135f6459d383c989b37836e2b687cdf0f2b72_sk -b admin:adminpw -d&#39; #该文件名应该对应着新生成的密钥文件进行修改 volumes: - ..&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;ca&#x2F;:&#x2F;etc&#x2F;hyperledger&#x2F;fabric-ca-server-config - .&#x2F;hosts:&#x2F;etc&#x2F;hosts container_name: ca_peerOrg2 network_mode: &quot;host&quot; # networks: # behave: # aliases: # - $&#123;CORE_PEER_NETWORKID&#125; 创建peer11.yml 123456789101112131415161718192021222324252627282930313233343536373839404142vi peer11.ymlversion: &#39;2&#39;networks: behave:services: peer1.org1.example.com: extends: file: docker-compose-base.yml service: peer container_name: peer1.org1.example.com environment: - CORE_PEER_CHAINCODELISTENADDRESS&#x3D;peer1.org1.example.com:7052 - CORE_PEER_ID&#x3D;peer1.org1.example.com - CORE_PEER_ADDRESS&#x3D;peer1.org1.example.com:7051 - CORE_PEER_GOSSIP_BOOTSTRAP&#x3D;peer0.org1.example.com:7051 - CORE_PEER_GOSSIP_ORGLEADER&#x3D;$&#123;CORE_PEER_GOSSIP_ORGLEADER_PEER1_ORG1&#125; - CORE_PEER_GOSSIP_USELEADERELECTION&#x3D;$&#123;CORE_PEER_GOSSIP_USELEADERELECTION_PEER1_ORG1&#125; - CORE_PEER_LOCALMSPID&#x3D;Org1MSP - CORE_PEER_TLS_CLIENTROOTCAS_FILES&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;users&#x2F;Admin@org1.example.com&#x2F;tls&#x2F;ca.crt - CORE_PEER_TLS_CLIENTCERT_FILE&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;users&#x2F;Admin@org1.example.com&#x2F;tls&#x2F;client.crt - CORE_PEER_TLS_CLIENTKEY_FILE&#x3D;&#x2F;var&#x2F;hyperledger&#x2F;users&#x2F;Admin@org1.example.com&#x2F;tls&#x2F;client.key volumes: - ..&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer1.org1.example.com&#x2F;msp:&#x2F;var&#x2F;hyperledger&#x2F;msp - ..&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer1.org1.example.com&#x2F;tls:&#x2F;var&#x2F;hyperledger&#x2F;tls - ..&#x2F;crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users:&#x2F;var&#x2F;hyperledger&#x2F;users - ..&#x2F;config&#x2F;:&#x2F;var&#x2F;hyperledger&#x2F;configs extra_hosts: - &quot;orderer0.example.com:191.8.2.156&quot; - &quot;orderer1.example.com:191.8.2.158&quot; - &quot;orderer2.example.com:191.8.2.159&quot; - &quot;peer0.org1.example.com:191.8.2.156&quot; networks: behave: aliases: - $&#123;CORE_PEER_NETWORKID&#125; ports: - 7051:7051 - 7053:7053 5、启动容器按照以下顺序启动容器 123456graph LRCA--&gt;ZookeeperZookeeper--&gt;kafkakafka--&gt;ordererorderer--&gt;peerpeer--&gt;cli 5.1 启动CA191.8.2.156 1docker-compose -f ca0.yml up -d 191.8.2.148 1docker-compose -f ca1.yml up -d 5.2 启动Zookeeper191.8.2.156 1docker-compose -f zookeeper0.yml up -d 191.8.2.158 1docker-compose -f zookeeper1.yml up -d 191.8.2.159 1docker-compose -f zookeeper2.yml up -d 5.3 启动kafka191.8.2.156 1docker-compose -f kafka0.yml up -d 191.8.2.158 1docker-compose -f kafka1.yml up -d 191.8.2.159 1docker-compose -f kafka2.yml up -d 191.8.2.147 1docker-compose -f kafka3.yml up -d 5.4 启动orderer191.8.2.156 1docker-compose -f orderer0.yml up -d 191.8.2.158 1docker-compose -f orderer1.yml up -d 191.8.2.159 1docker-compose -f orderer2.yml up -d 5.5 启动peer191.8.2.156 1docker-compose -f peer01.yml up -d 191.8.2.148 1docker-compose -f peer11.yml up -d 191.8.2.159 1docker-compose -f peer02.yml up -d 191.8.2.147 1docker-compose -f peer12.yml up -d 5.6 启动cli191.8.2.156 1docker-compose -f docker-compose-cli-org1.yml up -d 6、部署链码1234567891011121314151617181920212223242526272829303132docker exec -it cli &#x2F;bin&#x2F;bashexport CHANNEL_NAME&#x3D;mychannelpeer channel create -o orderer0.example.com:7050 -c $CHANNEL_NAME -f .&#x2F;channel-artifacts&#x2F;channel.tx --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer0.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pempeer channel join -b mychannel.blockCORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;users&#x2F;Admin@org2.example.com&#x2F;msp \\CORE_PEER_ADDRESS&#x3D;peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID&#x3D;&quot;Org2MSP&quot; \\CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;peers&#x2F;peer0.org2.example.com&#x2F;tls&#x2F;ca.crt \\peer channel join -b mychannel.blockpeer channel update -o orderer0.example.com:7050 -c $CHANNEL_NAME -f .&#x2F;channel-artifacts&#x2F;Org1MSPanchors.tx \\--cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer0.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pemCORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;users&#x2F;Admin@org2.example.com&#x2F;msp \\CORE_PEER_ADDRESS&#x3D;peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID&#x3D;&quot;Org2MSP&quot; \\CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;peers&#x2F;peer0.org2.example.com&#x2F;tls&#x2F;ca.crt \\peer channel update -o orderer0.example.com:7050 -c $CHANNEL_NAME -f .&#x2F;channel-artifacts&#x2F;Org2MSPanchors.tx \\--cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer0.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pempeer chaincode install -n sacc -v 1.0 -p github.com&#x2F;chaincode&#x2F;CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;users&#x2F;Admin@org2.example.com&#x2F;msp \\CORE_PEER_ADDRESS&#x3D;peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID&#x3D;&quot;Org2MSP&quot; \\CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;peers&#x2F;peer0.org2.example.com&#x2F;tls&#x2F;ca.crt \\peer chaincode install -n sacc -v 1.0 -p github.com&#x2F;chaincode&#x2F;peer chaincode instantiate -o orderer0.example.com:7050 -C mychannel -n emall_cc -v 1.2 -c &#39;&#123;&quot;Args&quot;:[&quot;init&quot;]&#125;&#39; --cafile &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;ordererOrganizations&#x2F;example.com&#x2F;orderers&#x2F;orderer0.example.com&#x2F;msp&#x2F;tlscacerts&#x2F;tlsca.example.com-cert.pem 7、部署效果191.8.2.156 191.8.2.158 191.8.2.159 191.8.2.148 191.8.2.147 参考配置文件地址：silence-lhl 有时候内网机器不能连接外网，也无法从外网直接拉取镜像，一般从跳板机将镜像拉取完成后保存并发送到内网机器，再在内网机器中进行加载，命令如下： docker save IMAGE_NAME IMAGE_NAME.tar docker load -i IMAGE_NAME.tar"},{"title":"docker +calico网络部署","date":"2019-03-16T14:31:12.000Z","path":"2019/03/16/calico/","text":"环境 IP 节点 环境 系统 192.168.15.33 node1 docker+etcd+calicoctl CentOS 7 192.168.15.34 node2 docker+etcd+calicoctl CentOS 7 步骤1）环境准备 修改主机名称 node1 12[root@localhost ~]# hostnamectl --static set-hostname node1[root@localhost ~]# echo &quot;node1&quot; &gt; &#x2F;etc&#x2F;hostname node2 12[root@localhost ~]# hostnamectl --static set-hostname node2[root@localhost ~]# echo &quot;node2&quot; &gt; &#x2F;etc&#x2F;hostname 关闭两台主机防火墙，若开启iptables防火墙，则打开2380端口 12345[root@localhost ~]# systemctl disable firewalld.service[root@localhost ~]# systemctl stop firewalld.service[root@localhost ~]# iptables -F[root@localhost ~]# firewall-cmd --statenot running 两台主机均设置hosts，都执行以下命令 1234[root@localhost ~]# vim &#x2F;etc&#x2F;hosts192.168.15.133 node1192.168.15.134 node2 将机器上的ip转发功能打开 12[root@localhost ~]# echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward[root@localhost ~]# sysctl -p 2）安装docker【两台机器上均安装】1234[root@localhost ~]# yum install -y docker[root@localhost ~]# systemctl start docker[root@localhost ~]# systemctl enable docker 3）安装etcd【两台机器上均安装】1[root@localhost ~]# yum install etcd -y 4）配置etcd集群node1 1234567891011121314[root@localhost ~]# cp &#x2F;etc&#x2F;etcd&#x2F;etcd.conf &#x2F;etc&#x2F;etcd&#x2F;etcd.conf.bak[root@localhost ~]#cat &gt; &#x2F;etc&#x2F;etcd&#x2F;etcd.conf &lt;&lt;EOF#[Member]ETCD_DATA_DIR&#x3D;&quot;&#x2F;var&#x2F;lib&#x2F;etcd&#x2F;default.etcd&quot;ETCD_LISTEN_PEER_URLS&#x3D;&quot;http:&#x2F;&#x2F;0.0.0.0:2380&quot;ETCD_LISTEN_CLIENT_URLS&#x3D;&quot;http:&#x2F;&#x2F;0.0.0.0:2379&quot;ETCD_NAME&#x3D;&quot;node1&quot;#[Clustering]ETCD_INITIAL_ADVERTISE_PEER_URLS&#x3D;&quot;http:&#x2F;&#x2F;192.168.15.133:2380&quot;ETCD_ADVERTISE_CLIENT_URLS&#x3D;&quot;http:&#x2F;&#x2F;192.168.15.133:2379&quot;ETCD_INITIAL_CLUSTER&#x3D;&quot;node1&#x3D;http:&#x2F;&#x2F;192.168.15.133:2380,node2&#x3D;http:&#x2F;&#x2F;192.168.15.134:2380&quot;EOF node2 1234567891011121314[root@localhost ~]# cp &#x2F;etc&#x2F;etcd&#x2F;etcd.conf &#x2F;etc&#x2F;etcd&#x2F;etcd.conf.bak[root@localhost ~]# cat &gt; &#x2F;etc&#x2F;etcd&#x2F;etcd.conf &lt;&lt;EOF#[Member]ETCD_DATA_DIR&#x3D;&quot;&#x2F;var&#x2F;lib&#x2F;etcd&#x2F;default.etcd&quot;ETCD_LISTEN_PEER_URLS&#x3D;&quot;http:&#x2F;&#x2F;0.0.0.0:2380&quot;ETCD_LISTEN_CLIENT_URLS&#x3D;&quot;http:&#x2F;&#x2F;0.0.0.0:2379&quot;ETCD_NAME&#x3D;&quot;node2&quot;#[Clustering]ETCD_INITIAL_ADVERTISE_PEER_URLS&#x3D;&quot;http:&#x2F;&#x2F;192.168.15.134:2380&quot;ETCD_ADVERTISE_CLIENT_URLS&#x3D;&quot;http:&#x2F;&#x2F;192.168.15.134:2379&quot;ETCD_INITIAL_CLUSTER&#x3D;&quot;node1&#x3D;http:&#x2F;&#x2F;192.168.15.133:2380,node2&#x3D;http:&#x2F;&#x2F;192.168.15.134:2380&quot;EOF 启动两个节点的etcd服务，以node1为例 12[root@localhost ~]# systemctl enable etcd[root@localhost ~]# systemctl start etcd 查看集群成员 1234567[root@localhost ~]# etcdctl member list8e92f64982d9786c: name&#x3D;node2 peerURLs&#x3D;http:&#x2F;&#x2F;192.168.15.134:2380 clientURLs&#x3D;http:&#x2F;&#x2F;192.168.15.134:2379 isLeader&#x3D;falsed3e45f62ae9d5a52: name&#x3D;node1 peerURLs&#x3D;http:&#x2F;&#x2F;192.168.15.133:2380 clientURLs&#x3D;http:&#x2F;&#x2F;192.168.15.133:2379 isLeader&#x3D;true[root@localhost ~]# etcdctl cluster-healthmember 8e92f64982d9786c is healthy: got healthy result from http:&#x2F;&#x2F;192.168.15.134:2379member d3e45f62ae9d5a52 is healthy: got healthy result from http:&#x2F;&#x2F;192.168.15.133:2379cluster is healthy 5）修改docker启动文件以支持etcdnode1 在ExecStart区域内添加 (在–seccomp-profile 这一行的下面一行添加–cluster-store=etcd://192.168.15.133:2379 \\ ) 12345678[root@localhost ~]# cp &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service.bak[root@localhost ~]# vim &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service........--seccomp-profile&#x3D;&#x2F;etc&#x2F;docker&#x2F;seccomp.json \\--cluster-store&#x3D;etcd:&#x2F;&#x2F;192.168.15.133:2379 \\[root@localhost ~]# systemctl daemon-reload[root@localhost ~]# systemctl restart docker node2 在ExecStart区域内添加 (在–seccomp-profile 这一行的下面一行添加–cluster-store=etcd://192.168.15.134:2379 \\ ) 12345678[root@localhost ~]# cp &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service.bak[root@localhost ~]# vim &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service........--seccomp-profile&#x3D;&#x2F;etc&#x2F;docker&#x2F;seccomp.json \\--cluster-store&#x3D;etcd:&#x2F;&#x2F;192.168.15.134:2379 \\[root@localhost ~]# systemctl daemon-reload[root@localhost ~]# systemctl restart docker 结果 发现当前docker支持了etcd，且由于etcd服务已经启动，所以可以看到etcd进程 1234[root@localhost ~]# ps -ef|grep etcdetcd 10293 1 0 19:47 ? 00:00:33 &#x2F;usr&#x2F;bin&#x2F;etcd --name&#x3D;node1 --data-dir&#x3D;&#x2F;var&#x2F;lib&#x2F;etcd&#x2F;default.etcd --listen-client-urls&#x3D;http:&#x2F;&#x2F;0.0.0.0:2379root 10426 1 0 19:54 ? 00:00:07 &#x2F;usr&#x2F;bin&#x2F;dockerd-current --add-runtime docker-runc&#x3D;&#x2F;usr&#x2F;libexec&#x2F;docker&#x2F;docker-runc-current --default-runtime&#x3D;docker-runc --exec-opt native.cgroupdriver&#x3D;systemd --userland-proxy-path&#x3D;&#x2F;usr&#x2F;libexec&#x2F;docker&#x2F;docker-proxy-current --init-path&#x3D;&#x2F;usr&#x2F;libexec&#x2F;docker&#x2F;docker-init-current --seccomp-profile&#x3D;&#x2F;etc&#x2F;docker&#x2F;seccomp.json --cluster-store&#x3D;etcd:&#x2F;&#x2F;192.168.15.133:2379 --selinux-enabled --log-driver&#x3D;journald --signature-verification&#x3D;false --storage-driver overlay2root 13333 1279 0 21:34 pts&#x2F;0 00:00:00 grep --color&#x3D;auto etcd 6）安装calico网络通信环境节点上先下载calico容器镜像 1[root@localhost ~]# docker pull quay.io&#x2F;calico&#x2F;node:v2.6.10 安装calicoctl【所有节点都需要安装】 12345[root@localhost ~]# wget https:&#x2F;&#x2F;github.com&#x2F;projectcalico&#x2F;calicoctl&#x2F;releases&#x2F;download&#x2F;v1.1.0&#x2F;calicoctl[root@localhost ~]# chmod 755 calicoctl[root@localhost ~]# mv calicoctl &#x2F;usr&#x2F;local&#x2F;bin&#x2F;[root@localhost ~]# calicoctl --versioncalicoctl version v1.1.0, build 882dd008 分别在两个节点上创建calico容器 node1 12[root@localhost ~]# docker run --net&#x3D;host --privileged --name&#x3D;calico-node -d --restart&#x3D;always -e NODENAME&#x3D;node1 -e CALICO_NETWORKING_BACKEND&#x3D;bird -e CALICO_LIBNETWORK_ENABLED&#x3D;true -e IP&#x3D;192.168.15.133 -e ETCD_ENDPOINTS&#x3D;http:&#x2F;&#x2F;127.0.0.1:2379 -v &#x2F;var&#x2F;log&#x2F;calico:&#x2F;var&#x2F;log&#x2F;calico -v &#x2F;var&#x2F;run&#x2F;calico:&#x2F;var&#x2F;run&#x2F;calico -v &#x2F;lib&#x2F;modules:&#x2F;lib&#x2F;modules -v &#x2F;run:&#x2F;run -v &#x2F;run&#x2F;docker&#x2F;plugins:&#x2F;run&#x2F;docker&#x2F;plugins -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock quay.io&#x2F;calico&#x2F;node:v2.6.10 node2 1[root@localhost ~]# -e CALICO_NETWORKING_BACKEND&#x3D;bird -e CALICO_LIBNETWORK_ENABLED&#x3D;true -e IP&#x3D;192.168.15.134 -e ETCD_ENDPOINTS&#x3D;http:&#x2F;&#x2F;127.0.0.1:2379 -v &#x2F;var&#x2F;log&#x2F;calico:&#x2F;var&#x2F;log&#x2F;calico -v &#x2F;var&#x2F;run&#x2F;calico:&#x2F;var&#x2F;run&#x2F;calico -v &#x2F;lib&#x2F;modules:&#x2F;lib&#x2F;modules -v &#x2F;run:&#x2F;run -v &#x2F;run&#x2F;docker&#x2F;plugins:&#x2F;run&#x2F;docker&#x2F;plugins -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock quay.io&#x2F;calico&#x2F;node:v2.6.10 查看calico容器创建情况（以node1为例） 123456789101112131415[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2d9f4e006b37 quay.io&#x2F;calico&#x2F;node:v2.6.10 &quot;start_runit&quot; About an hour ago Up About an hour calico-node[root@localhost ~]# ps -ef|grep calicoroot 11112 11109 0 20:24 ? 00:00:00 svlogd -tt &#x2F;var&#x2F;log&#x2F;calico&#x2F;bird6root 11113 11109 0 20:24 ? 00:00:00 bird6 -R -s &#x2F;var&#x2F;run&#x2F;calico&#x2F;bird6.ctl -d -c &#x2F;etc&#x2F;calico&#x2F;confd&#x2F;config&#x2F;bird6.cfgroot 11114 11110 0 20:24 ? 00:00:00 svlogd &#x2F;var&#x2F;log&#x2F;calico&#x2F;confdroot 11115 11110 0 20:24 ? 00:00:00 confd -confdir&#x3D;&#x2F;etc&#x2F;calico&#x2F;confd -interval&#x3D;5 -watch --log-level&#x3D;info -node&#x3D;http:&#x2F;&#x2F;127.0.0.1:2379 -client-key&#x3D; -client-cert&#x3D; -client-ca-keys&#x3D;root 11116 11111 0 20:24 ? 00:00:00 svlogd &#x2F;var&#x2F;log&#x2F;calico&#x2F;libnetworkroot 11118 11107 0 20:24 ? 00:00:00 svlogd &#x2F;var&#x2F;log&#x2F;calico&#x2F;felixroot 11120 11108 0 20:24 ? 00:00:00 svlogd -tt &#x2F;var&#x2F;log&#x2F;calico&#x2F;birdroot 11121 11108 0 20:24 ? 00:00:00 bird -R -s &#x2F;var&#x2F;run&#x2F;calico&#x2F;bird.ctl -d -c &#x2F;etc&#x2F;calico&#x2F;confd&#x2F;config&#x2F;bird.cfgroot 11455 11107 0 20:34 ? 00:00:28 calico-felixroot 13771 1279 0 21:49 pts&#x2F;0 00:00:00 grep --color&#x3D;auto calico 查看calico状态 node1 123456789101112[root@localhost ~]# calicoctl node statusCalico process is running.IPv4 BGP status+----------------+-------------------+-------+----------+-------------+| PEER ADDRESS | PEER TYPE | STATE | SINCE | INFO |+----------------+-------------------+-------+----------+-------------+| 192.168.15.134 | node-to-node mesh | up | 12:24:19 | Established |+----------------+-------------------+-------+----------+-------------+IPv6 BGP statusNo IPv6 peers found. node2 123456789101112[root@localhost ~]# calicoctl node statusCalico process is running.IPv4 BGP status+----------------+-------------------+-------+----------+-------------+| PEER ADDRESS | PEER TYPE | STATE | SINCE | INFO |+----------------+-------------------+-------+----------+-------------+| 192.168.15.133 | node-to-node mesh | up | 12:24:21 | Established |+----------------+-------------------+-------+----------+-------------+IPv6 BGP statusNo IPv6 peers found. 7）添加calico网络注：只需要在一个节点配置添加即可 node1 创建ip pool 123456789101112[root@localhost ~]# cat &gt;ipPool.yaml &lt;&lt;EOF- apiVersion: v1 kind: ipPool metadata: cidr: 10.20.0.0&#x2F;24 spec: ipip: enabled: true nat-outgoing: trueEOF[root@localhost ~]# calicoctl create -f ipPool.yaml 在任意节点查看添加ip pool情况 12345[root@localhost ~]# calicoctl get ipPoolCIDR 10.20.0.0&#x2F;24 192.168.0.0&#x2F;16 fd80:24e2:f998:72d6::&#x2F;64 在上面创建的ip pool(10.20.0.0/24)里创建子网络 12[root@localhost ~]# docker network create --driver calico --ipam-driver calico-ipam --subnet 10.20.0.0&#x2F;24 net1[root@localhost ~]# docker network create --driver calico --ipam-driver calico-ipam --subnet 10.20.0.0&#x2F;24 net2 查看网络创建情况，可以看到net1、net2的网络已经存在 1234567[root@localhost ~]# docker network lsNETWORK ID NAME DRIVER SCOPEdd3ae1400375 bridge bridge localb87973f6e3da host host localaaea1c24a3d6 net1 calico globalefebcca875b3 net2 calico global0fd941dfe66b none null local 在node1和node2上创建容器来测试下容器网络的连通性 下载busybox工具，方便测试使用 1[root@localhost ~]# docker pull busybox node1 12[root@localhost ~]# docker run --net net1 --name workload-A -tid busybox[root@localhost ~]# docker run --net net2 --name workload-B -tid busybox node2 1[root@localhost ~]# docker run --net net1 --name workload-E -tid busybox 同一网络内的容器（即使不在同一节点主机上）可以使用容器名来访问 node1 12345678910[root@localhost ~]# docker exec workload-A ping -c 4 workload-E.net1PING workload-E.net1 (10.20.0.1): 56 data bytes64 bytes from 10.20.0.1: seq&#x3D;0 ttl&#x3D;62 time&#x3D;0.811 ms64 bytes from 10.20.0.1: seq&#x3D;1 ttl&#x3D;62 time&#x3D;0.220 ms64 bytes from 10.20.0.1: seq&#x3D;2 ttl&#x3D;62 time&#x3D;0.157 ms64 bytes from 10.20.0.1: seq&#x3D;3 ttl&#x3D;62 time&#x3D;0.231 ms--- workload-E.net1 ping statistics ---4 packets transmitted, 4 packets received, 0% packet lossround-trip min&#x2F;avg&#x2F;max &#x3D; 0.157&#x2F;0.354&#x2F;0.811 ms node2 12345678910[root@localhost ~]# docker exec workload-E ping -c 4 workload-A.net1PING workload-A.net1 (10.20.0.129): 56 data bytes64 bytes from 10.20.0.129: seq&#x3D;0 ttl&#x3D;62 time&#x3D;1.964 ms64 bytes from 10.20.0.129: seq&#x3D;1 ttl&#x3D;62 time&#x3D;1.152 ms64 bytes from 10.20.0.129: seq&#x3D;2 ttl&#x3D;62 time&#x3D;0.521 ms64 bytes from 10.20.0.129: seq&#x3D;3 ttl&#x3D;62 time&#x3D;0.503 ms--- workload-A.net1 ping statistics ---4 packets transmitted, 4 packets received, 0% packet lossround-trip min&#x2F;avg&#x2F;max &#x3D; 0.503&#x2F;1.035&#x2F;1.964 ms 不同网络内的容器需要使用容器ip来访问 使用容器名会报：bad address 12[root@localhost ~]# docker exec workload-A ping -c 4 workload-B.net2ping: bad address &#39;workload-B.net2&#39; 使用容器ip（这个还没尝试成功） 1docker exec workload-A ping -c 2 &#96;docker inspect --format &quot;&#123;&#123; .NetworkSettings.Networks.net2.IPAddress &#125;&#125;&quot; workload-B&#96;"},{"title":"IPv6-router","date":"2018-11-10T03:40:02.000Z","path":"2018/11/10/IPv6-router/","text":"1、IPv6路由1.1 源和目的机在同一链路的数据转发（on-link) 通过地址前缀判断是否同一链路：on-link 发起地址解析（与v4的ARP不同） 独立于媒体层 利用三层安全机制 改广播为组播，降低骚扰范围 由ND协议完成 1.1.1 ND（Neighbor Discover,邻居发现）协议 地址解析 替代ARP 邻居不可达检测 无状态地址自动配置 路由器发现 接口ID自动生成 重复地址检测（DAD） 前缀重新编址 路由器重定向 ICMPv6类型 消息名称 ICMPv6类型 消息名称 Type=133 RS (路由器请求) Type=136 NA (邻居公告) Type=134 RA (路由器公告) Type=137 Redirect Type=135 NS (邻居请求) IPv6地址解析 查找邻居缓存表（ipv6 nc），没有则进行地址解析 源主机发送组播NS报文，该报文的目的地址为目标IPv6地址所对应的被请求节点组播地址(Solicted-node)，在其中也包括了自己的链路层地址； 目标主机收到NS报文之后，就会得到发送主机的IPv6地址和相应的链路层地址； 目标主机向源主机单播发一个邻接点公告报文(NA)，该报文中包含自己的链路层地址 实例： Attention: 邻居缓存表(neighbor cache) 存储最近通过信的邻居的信息 每条记录包括单播IPv6地址、MAC地址、标记、下次NUD时间 NUD：Neighbor Unreachability Detection,不可达检测，测试自己和邻居之间的通达性 邻居缓存表中记录的状态： 状态 含义 INCOMPLETE（未完成状态） 添加新记录，还未有MAC地址，可尝试多次组播NS REACHABLE（可达状态） 收到NA确认 STALE（失效状态） 已经过了reachable time时效 DELAY（延迟状态） 等待NA确认，默认5s PROBE（探测状态） delay时效过， 可发3次（间隔1s） NS 1.2 源和目的机不在同一链路的数据转发（off-link）1.2.1 主机——路由器(主机发给哪个路由器)DestinationCache（目的缓存表） 初始时为空 某个地址在该表中查不到时， 改查路由表， 做on-link判断： 是on-link的，将目的地址本身加入DC表的nexthop域； 是off-link的，将路由表中的下一跳加入DC的nexthop域。 重定向问题 优化主机-路由器之间的路由若路由器发现报文的出口和入口相同或者源地址与报文下一跳同属一个网段，则发出重定向报文。 1.2.2 路由器——路由器(路由器发给哪个路由器)核心：路由表 直连路由 静态路由 IPv4：ip route IPv6：ipv6 route 动态路由 内部网关协议 距离矢量路由选择协议：RIPng 链路状态路由选择协议：OSPFv3 边界网关协议 BGP4+ 2、IPv6过渡技术2.1 三种主要地方共存技术2.1.1 双栈 网络设备上运行IPv6/IPv4双协议栈 适用于混合环境。基础设施设备，如路由器、交换机、公用服务器等需要运行和支持双栈； 到底使用哪个地址：选择高优先级地址，根据地址选择策略表：优先级、范围 Happy eyeballs dual stack 先尝试IPv6，不成功则转向IPv4 要求，DNS服务器有双栈记录，“A”，“AAAA” 2.1.2 隧道 IPv6网络上承载IPv4分组，或相反 大致分为两类 手动隧道：事前配置 自动隧道：创建和拆除都依赖当前网络条件 IPv6分组通过IPv4网络 适用于IPv6孤岛情形 IPv6分组作为载荷搭载到IPv4分组中，在这种情形下，IPv4分组头部的protocol=41 IPv4分组通过IPv6网络 类似IPv6通过IPv4 DSTM(Dual Stack Transition Mechanism) 2.1.3 翻译/转换 地址、分组、端口的转换 从IPv4转换到IPv6， 或反过来，不仅发生在网络层还有传输层和应用层 当双栈和隧道都无法使用的时候，才使用；适用纯IPv4节点和IPv6节点的通信。"},{"title":"IPv6-packet","date":"2018-11-09T07:29:09.000Z","path":"2018/11/09/IPv6-packet/","text":"1、IPv6报文一般格式 1.1 IPv6与IPv4报文比较 报头变化： IPv4最小报头：20字节 IPv6固定报头：40字节 修改项 地址：32位——&gt; 128位 TTL ——&gt; 跳数限制 协议 ——&gt; 下一报头 服务质量 ——&gt; 流量类型 删除的项 分片域 IP选项 校验和 HL 数据报长度 增加的项 流标签 1.2 IPv6扩展报头主要的扩展报头： 逐跳选项路由报头分段报头认证报头封装安全有效载荷报头目标选项 扩展报头 next header value 逐跳扩展头 0 ICMPv4 1 TCP 6 UDP 17 路由扩展头 43 ICMPv6 58 OSPF 89 没有下一个报头 59 扩展头顺序 逐跳选项报头 目标选项报头1（当存在路由报头时，用于中间目标） 路由报头 分片段报头 身份验证报头 封装安全有效载荷报头 目标选项报头2（用于最终目标） 1.2.1 逐跳选项报头 存放沿途所有路由器必须检查的信息！ 定义一些选项：eg：巨形数据报 选项按照类型、长度、值出现 选项字段最高两位含义如下： 00 ：跳过该选项 01 ：丢弃数据包，不通知发送方 10 ：丢弃数据包，无论数据包目标地址是否为一个组播地址，都向发送方发出ICMPv6参数问题的报文 11 ：丢弃数据包，如果数据包的目标地址不是一个组播地址，就向发送方发出一个ICMPv6参数问题的报文 选项字段最高第三位表示在通向目标的路径中，选项数据是否可以改变 0 ：选项数据不能改变 1 ：选项数据可以改变 当路由器识别不出对应类型的时候，执行相应动作。 1.2.2 路由报头使数据分组经过指定的中间节点到达目的地。 剩余分段：表示地址表中还有多少个地址未被访问！每过一个列表中的地址 -1 当数据到达每个中间目标地址的时候，执行动作如下： 当前目标地址与第（n-段剩余值+1）个地址交换；（n是地址总数） 段剩余值减1 转发 2.ICMPv6协议ICMPv6报文类型 差错报文：通告IPv6分组传输中出现的错误 目标不可达 数据包超长 超时 参数问题 信息报文：提供诊断和附加的主机功能 MLD ND(ARP,redirect) 回声请求和应答 2.1 ICMPv6报文的一般格式 差错报文：类型=0 xxxxxxx =0 ~ 127 信息报文：类型=1 xxxxxxx =128 ~255 128: 回声请求 129：回声应答 2.2 ICMPv6的三个应用 ping tracert 第一个请求：HopLim=1(TTL=1) 第一跳路由器收到，发送超时消息 得到第一跳路由器信息 第二个请求：HopLim=2(TTL=2) 第二跳路由器收到，发送超时消息 得到第二跳路由器信息 …… 指导目的地，目的机通常发送端口不可达报文 PMTU发现 MTU：最大传输单元，在IPv4网络中可能由路由器承担分段，容易遭受分片型攻击，在IPv6中规定分段不能由路由器承担，只能由发送方分段（切割数据来适应载重能力），因此在IPv6中，要求源节点（发送方）必须在发送数据之前知道整个传输路径的最小MTU PMTU发现原理（试探） 源机向目的机发送MTU=1500字节的IPv6数据包 路由器B向源发送超长信息，指定MTU=1400字节 源机向目的机发送MTU=1400字节的IPv6数据包 路由器C向源发送超长消息，指定MTU=1300字节 源机向目的机发送MTU=1300字节的IPv6数据包 此后，该路径的MTU都使用1300字节"},{"title":"IPv6(2)","date":"2018-10-25T06:35:12.000Z","path":"2018/10/25/IPv6-2/","text":"5.2 组播地址（Multicast Address) 其中 Flags： 0001 （表示permanent)或 0000(表示临时组播组) Scope： 表示组播组范围 范围值 范围 范围值 范围 0 保留 8 组织-本地范围 1 节点-本地范围 9 未分配 2 链路-本地范围 A 未分配 3 未分配 B 未分配 4 未分配 C 未分配 5 站点-本地范围 D 未分配 6 未分配 E 全局范围 7 未分配 F 保留 Group ID： 组播组ID 5.2.1 一些熟知的组播地址节点-本地范围 FF01：:1 所有-节点地址 FF01：:2 所有-路由器地址 链路-本地范围 FF02：:1 所有-节点地址 FF02：:2 所有-路由器地址 5.2.2 特殊的组播地址 Solicited-node节点地址：被请求节点组播地址，主要用于重复地址检测和获取邻居节点的链路层地址 地址构成： 前104位：FF02：:1:FF/104(64个0) 后24位：单播地址的后24位 工作范围：在本地链路上有效 凡是单播地址后24位相同的接口自动加入相应的请求节点组播组！ 作用： 1、在IPV6中，没有ARP。ICMP代替了ARP的功能，被请求节点的组播地址被节点用来获得相同本地链路上邻居节点的链路层地址 2、用于重复地址检测DAD，在使用无状态自动配置将某个地址配置为自已的IPV6地址之前，节点利用DAD验证在其本地链路上该地址是否已经被使用。 5.3 任播地址（Anycast Address)IPv6地址新类型： IPv6中一个任播地址是分配给不同节点的多个接口的，就是说有若干个网络接口可分配同一个任播地址。当有一个数据包传送给这个地址时，路由器只将此数据包转发到其中一个“最近距离”的接口上就结束了，并不是每个接口都收到此数据包。（这一点上也与IPv6多播不同。） 另外，单从IPv6的地址形式上是无法区分单播与任播地址的 目标地址为任播地址的数据报将发送给最近的一个接口 适合与One-to-One of Many（一对多之一）的通讯场合 仅能做目标地址，且仅分配给路由器 6.一台IPv6主机，一个接口上可以具有的IPv6地址 名称 地址 链路本地地址 FE80::/10 环回地址 ::1/128 所有节点组播地址 FF01：:1(本地接口范围)，FF02::1(本地链路范围) 分配的可聚合全球单播地址 2000::/3 被请求节点组播地址 FF02::1:FF00:/104 主机所属组的组播地址 FF00::/8 7.IPv6地址配置 手工配置 无状态地址自动配置（ND协议） 有状态地址自动配置（DHCPv6） 默认情况下，IPv6主机可以为每个接口配置一个链路本地地址 7.1 无状态地址自动配置（SLAAC）无需任何配置即可与外界通信 无状态地址自动配置基于对主机使用的IPv6地址的如下结构：由前缀 和 接口ID 组成 接口ID：EUI-64 前缀一般是路由器前缀，运行一个无需主机配置的协议即可。 无状态地址自动配置用到的消息Router Solicitation (RS):促使路由器发送RA消息 Router Advertisement (RA)：向主机通告前缀等信息 两种消息都是以ICMP报文形式出现，也是5种ND协议消息中的两种 无状态地址自动配置中的3个机制(1)路由发现 主机选择默认网关 主机发现前缀，生成前缀列表 参数发现：发现相关参数的过程，如MTU，跳数限制、地址配置方式等 路由发现实例 主机请求——触发路由器 注意要点： 节点启动最多只能发送3个RS，避免RS泛滥 主机收到路由器RA之后，自动设置默认路由器，建立默认路由器列表、前缀列表及其它参数 路由器会主动周期性发送RA（默认值200秒） 关于地址的生存期：自动配置的IPv6地址在系统中you一个生存周期，跟++优先时间++和++有效时间++有关，对应4种状态 RA消息种prefix选项 在Preferred Lifetime周期内的前缀生成的地址，任何上层应用都可不受限制地使用 在超过Preferred Lifetime 但未超过ValidLifetime周期内的前缀生成的地址， 正在使用该地址的上层应用可继续使用， 但任何新的上层应用不能使用这个地址 在超过Valid Lifetime周期内的前缀构造的地址，任何上层应用都不能使用该地址 Attention:一个链路本地地址的优先时间和有效时间是无限的，即永不超时 RA消息中的M和O选项 (2)重复地址检测（Duplicate Address Detection：DAD） 节点确定即将使用的地址是否在链路上唯一的过程，对于所有的IPv6地址，不管是自动配置还是手动配置，都必须要通过DAD，DAD机制通过ND中的NS/NA两种消息实现 基本思想 一个地址在分配给一个接口之后且通过重复地址检测之前称为tentative地址，即试验地址 节点组播发送Neighbor Solicitation 若接收到Neighbor Advertisment，就证明地址重复 若尝试若干次请求，没有收到邻居通告，即可启用该地址 实例 若NS接受者发现目标域中地址对它而言是临时的，则主动放弃使用该地址 若NS接收者发现目标域中地址是一个它正在使用的地址，则发送NA消息，请求发起者将放弃使用该临时地址 (3)前缀重新编址 允许从旧前缀平稳过渡到新前缀，提供对用户透明的网络重新编址能力 当前缀重新编址的时候，路由器会继续通告当前前缀，只是优先时间和有效时间被减到接近0，同时路由器开始通告新的前缀，此时链路中至少有两个前缀共存 当节点收到这样的RA的时候，会发现当前前缀的生命周期较短，停止使用；同时开始使用新的前缀配置接口，并进行DAD，通过后，获得新的地址使用。 Attention:在转换期间，节点有两个单播地址使用。旧的地址是基于旧的前缀，用以维持以前已经建立的连接。新的地址是基于新的前缀，用来建立新的连接。当旧的前缀的有效时间递减为0时，旧的前缀完全废止，此时，RA中只包含新的前缀 小结：4中ND协议消息交互 7.2 有状态地址自动配置（DHCPv6）DHCPv6：Dynamic Host Configuration Protocol for ipv6 在有无状态地址自动配置的情况下，仍然需要DHCPv6的原因： 需要动态指定DNS服务 不想MAC地址成为IPv6地址的一部分 需要良好扩展性 特点 使用UDP来交换报文，端口546/547(v4：67/68),使用本地链路地址或其它机制获得的地址来发送和接收DHCPv6报文。没有了广播， 客户机只需发送给保留的链路范围组播地址，取消了DHCPv4中的Discover和Offer消息 DHCPv6获取地址和参数的典型过程 4步交互地址分配 快速地址配置 只需要两个信息交互 当客户端已经记录了地址和其他配置信息 只需要DNS server、NTP Server等信息 DHCPv6重配置机制 8.IPv6地址子网规划IPv4地址进行子网划分是为了管理地址稀缺性 IPv6子网划分是根据路由器数量以及支持的网络来构建寻址分层结构"},{"title":"IPv6(1)","date":"2018-10-24T12:43:33.000Z","path":"2018/10/24/IPv6-1/","text":"1.四层TCP/IPv6参考模型Application Layer ——HTTP,FTP,SMTP,SIP,RTP,DNS,DHCPv6，etc. Transport Layer ——TCPv6，UDPv6，SCTP Internet Layer —— IPv6，ICMPv6，IPsec Link Layer —— ND,OSPFv3,L2TP,PPP,Ethernet,DSL,MPLS,etc. 2.IPv6基本术语 局域网段：位于内部交换机下的网段 链路：内部子网路由器下 子网：多个链路可以组成子网 网络：不同子网可构成网络 3.IPv6地址为128位地址空间非常大，可以夸张地说，世界上每一粒沙子都可以有对应的IPv6地址。 4.IPv6地址表示格式：冒分十六进制128位IPv6地址如下： 1200100000000000010000010000010000000000000000000000000000000000010000000000000000000000000000000000000000000000000100010111111111 每16位一组，分为8组如下： 120010000000000001 0000010000010000 0000000000000000 00000000000000010000000000000000 0000000000000000 0000000000000000 0100010111111111 每一组中，每4为单位以16进制表示如下： 1234567890010 0000 0000 0001 20010000 0100 0001 0000 04100000 0000 0000 0000 00000000 0000 0000 0001 00010000 0000 0000 0000 00000000 0000 0000 0000 00000000 0000 0000 0000 00000100 0101 1111 1111 45ff 将8组16进制数用冒号连接如下： 12001:0410:0000:0001:0000:0000:0000:45ff 为了简洁表示，IPv6冒分十六进制有以下规则 规则1： 省略前导0，如果每组16进制数中存在前导0，则省略 2001:0410:0000:0001:0000:0000:0000:45ff 省略前导0，结果如下： 12001:410:0:1:0:0:0:45ff 规则2： 忽略全0 2001:410:0:1:0:0:0:45ff 结果如下 12001:410:0:1::45ff 注意：如果有多个部分有全0部分只能忽略一个部分的全0，如： 12001:0:0:1:0:0:0:45ff 只能写成 123452001::1:0:0:0:45ff或者2001:0:0:1::45ff 以下写法为错误写法： 12001::1::45ff 因为这样写无法确定省略了0的个数 5.IPv6地址分类与IPv4地址相比少了广播地址 5.1 单播地址（Unicast Address)IPv6单播地址用于唯一标识支持IPv6的设备上的接口，源IPv6地址必须为单播地址 本地链路地址 全局单播地址 环回地址 唯一本地地址 嵌入式IPv4地址 未指定地址 5.1.1本地链路地址目的：用于与统一链路中的其他设备通信 注意：路由器不会转发具有本地链路源地址或目的地址的数据包，每个支持IPv6的网络接口一定有本地链路地址。 支持IPv6的主机会创建IPv6本地链路地址，而IPv4的本地链路地址不会自动生成。 1. 链路本地地址的构成 应用范围：只能在同一本地链路节点之间使用，FE80::/64 节点启动时会自动配置一个本地链路地址。 2.链路本地地址的一种生成方法 前64位：FE80：0：0：0 后64位：EUI-64地址 EUI-64地址生成 MAC地址为48位，从中间切分为两部分各24位； 在这两部分之间插入16位数：11111111 11111110 组成64位地址； 将从头开始数的第7位取反，得到最终EUI-64地址 例：一台主机的MAC地址是： 0012:3400:ABCD， 试求其生成的链路本地地址 MAC地址写成二进制 100000000 00010010 00110100 00000000 10101011 11001101 中间插入 11111111 11111110 100000000 00010010 00110100 11111111 11111110 00000000 10101011 11001101 第7位取反 100000010 00010010 00110100 11111111 11111110 00000000 10101011 11001101 得到EUI-64地址 10212:34FF:FE00:ABCD 与前64位组合生成本地链路地址 1FE80::0212:34FF:FE00:ABCD 3.本地链路地址用途 主机使用本地路由器的本地链路地址作为默认网关IPv6地址 路由器使用本地链路地址交换动态路由协议消息 转发 IPv6 数据包时， 路由器的路由表使用本地链路地址确定下一跳路由器 5.1.2 环回地址 环回地址除最后一位外全为0，压缩格式表示为::1/128 主机使用环回地址发送数据包到其自身，环回地址不能分配给物理接口 5.1.3 未指定地址 未指定地址为全0地址，压缩格式表示为::/128或:: 不能分配给接口。仅作为IPv6数据包源地址，在设备尚无永久IPv6地址时，未指定地址可作为源地址，不能作为目的地址。 5.1.4 唯一本地地址 类似于IPv4的私有地址，但也有重大差异，范围从FC00::/7到FDFF::/7 唯一本地地址在一个站点内或有限站点数之间用作本地地址，在全局IPv6中不具有可路由性 5.1.5 可聚合全球单播地址 由格式前缀001标识，ISP商分配的前缀：/48，全球路由前缀 Site拓扑：由组织机构划分子网，子网ID 接口ID：64 接口ID生成方法： EUI-64（MAC地址生成） 随机生成（RFC3041） 手工设置 5.1.5 特殊单播地址 IPv6兼容地址：0：0：0：0：0：0：w:x:y:z 或 ::w.x.y.z IPv4映射地址：0：0：0：0：0：FFFF:w.x.y.z或::FFFF:w.x.y.z 6to4地址"},{"title":"CentOS以太坊私链搭建","date":"2018-10-02T02:47:59.000Z","path":"2018/10/02/centos-ethereum-establish/","text":"一、安装golang语言1yum install golang 也可以直接下载对应版本安装： 12wget https:&#x2F;&#x2F;studygolang.com&#x2F;dl&#x2F;golang&#x2F;go1.10.1.linux-amd64.tar.gztar -xvf go1.10.1.linux-amd64.tar.gz 二、安装以太坊下载 1wget https:&#x2F;&#x2F;github.com&#x2F;ethereum&#x2F;go-ethereum&#x2F;archive&#x2F;v1.8.3.tar.gz 解压并编译 123tar -zxvf v1.8.3.tar.gzcd go-ethereum-1.8.3make 三、运行以太坊 进入对应目录 1cd build&#x2F;bin&#x2F; 配置创世块 1234567891011121314151617181920vim genesis.json&#123; &quot;config&quot;:&#123; &quot;chainId&quot;:15, &quot;homesteadBlock&quot;:0, &quot;eip155Block&quot;:0, &quot;eip158Block&quot;:0 &#125;, &quot;nonce&quot;:&quot;0x0000000000000056&quot;, &quot;mixhash&quot;:&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;difficulty&quot;: &quot;0x400&quot;, &quot;alloc&quot;: &#123;&#125;, &quot;coinbase&quot;:&quot;0x0000000000000000000000000000000000000000&quot;, &quot;timestamp&quot;: &quot;0x00&quot;, &quot;parentHash&quot;:&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;extraData&quot;: &quot;&quot;, &quot;gasLimit&quot;:&quot;0xffffffff&quot;&#125; 初始化私链 1.&#x2F;geth --datadir data --networkid 20180929 --rpc --rpccorsdomain &quot;*&quot; init genesis.json 运行私链 12.&#x2F;geth --datadir data --networkid 20180929 --rpc --rpcaddr &quot;192.168.10.18&quot; --rpccorsdomain &quot;*&quot; --nodiscover --port 30303 --rpcport 8545 console 其中 –rpcaddr “192.168.10.18”为可选参数，当需要外部访问私链时需要绑定本机ip 四、使用screen管理会话为了防止远程连接中断导致私链停止运行，使用screen来管理会话 当需要运行私链前 1screen -S yourname -&gt; 新建一个叫yourname的session 切出当前会话 ctrl+A+D 1C-a d -&gt; detach，暂时离开当前session，将目前的 screen session (可能含有多个 windows) 丢到后台执行，并会回到还没进 screen 时的状态，此时在 screen session 里，每个 window 内运行的 process (无论是前台&#x2F;后台)都在继续执行，即使 logout 也不影响。 重新连接后台会话 1screen -r yourname -&gt; 回到yourname这个session"},{"title":"Ubuntu以太坊私链搭建","date":"2018-10-01T13:19:47.000Z","path":"2018/10/01/ubuntu-ethereum-establish/","text":"一、安装以太坊（Ethereum）客户端执行以下命令，安装以太坊客户端 1234567apt-get updateapt-get install software-properties-commonadd-apt-repository -y ppa:ethereum&#x2F;ethereumadd-apt-repository -y ppa:ethereum&#x2F;ethereum-devapt-get updateapt-get install ethereum 安装完成后，命令行输入 1geth -h 出现上图信息说明安装成功！ 二、创建私链2.1 创建创世块创建一个genesis.json文件，并将以下内容写到该文件中并保存 123456789101112131415161718&#123;&quot;config&quot;:&#123;&quot;chainId&quot;:15,&quot;homesteadBlock&quot;:0,&quot;eip155Block&quot;:0,&quot;eip158Block&quot;:0&#125;,&quot;nonce&quot;:&quot;0x0000000000000056&quot;,&quot;mixhash&quot;:&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,&quot;difficulty&quot;: &quot;0x40000&quot;,&quot;alloc&quot;: &#123;&#125;,&quot;coinbase&quot;:&quot;0x0000000000000000000000000000000000000000&quot;,&quot;timestamp&quot;: &quot;0x00&quot;,&quot;parentHash&quot;:&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,&quot;extraData&quot;: &quot;&quot;,&quot;gasLimit&quot;:&quot;0xffffffff&quot;&#125; 2.2 初始化私链1geth --datadir data --networkid 20140628 --rpc --rpccorsdomain &quot;*&quot; init .&#x2F;genesis.json 其中 ==init==后面所带的为上面所创建genesis.json文件路径 2.3 启动私链1geth --datadir data --networkid 20140628 --rpc [--rpcaddr &quot;192.168.10.150&quot;] --rpccorsdomain &quot;*&quot; --nodiscover --port 30303 --rpcport 8545 console 其中==–rpcaddr==为可选部分，如果需要外部访问私链，需要将运行节点本机ip绑定 –rpcaddr “192.168.10.150” 2.4 创建账号并开始挖矿 创建账号 personal.newAccount(“123456”); 括号中参数为账号私钥密码 2.开启/停止挖矿 miner.start(‘1’) 括号中参数代表参与挖矿线程，若不加此参数则会使用机器所有线程进行挖矿 miner.stop() 2.5 其它相关命令查询第一个账户余额 1web3.fromWei(web3.eth.getBalance(web3.eth.accounts[0]),&quot;ether&quot;) 查询第二个账户余额 1web3.fromWei(web3.eth.getBalance(web3.eth.accounts[1]),&quot;ether&quot;) 第一个账户向第二个账户转入50 ether 1web3.eth.sendTransaction(&#123;from:web3.eth.accounts[0] , to: web3.eth.accounts[1],value: web3.toWei(50, &quot;ether&quot;)&#125;) 为第一个账户解锁，一般在发起交易时需要使用 1personal.unlockAccount(web3.eth.accounts[0]) 连接geth控制台 1.&#x2F;geth attach http:&#x2F;&#x2F;127.0.0.1:8545"},{"title":"终于有一个自己的博客了！！","date":"2018-09-30T16:00:00.000Z","path":"2018/10/01/hello-world/","text":"喜大普奔啊！利用hexo快速地搭建了自己的博客 Harlan! 以后这个博客会作为我学习内容记录的一部分，我将会把自己学习的一些内容在这个博客中记录。作为菜鸟的我，还是不敢说做技术分享的！！该博客仅为本人的笔记。将会记录内容包括：课程学习内容、 技术学习内容 ，甚至还有吐槽，hhh！ 个人博客为什么要搭建博客？作为一个程序猿大学毕业还没有自己的博客，实在是太不像话了，还不赶紧neng一个！！（其实就是想找个属于自己的地方） 博客会用来干嘛？废话，当然用来写写写的呀！难道用来唠嗑吗？（不好意思，用来唠嗑也是挺好的感觉）当然，博客中会记录自己在每段时间的学习内容，任何学习内容都有可能出现，只要不违法！游戏内容应该就不会出现了，毕竟本人是个不玩游戏的假程序猿 真的会写下去吗？不知道诶，也许是一时兴起呢！ 记录一下发文章的步骤 步骤一：创建新文章 hexo new title 步骤二：编写新文章 步骤三：生成并部署 hexo g -d / hexo d -g"}]